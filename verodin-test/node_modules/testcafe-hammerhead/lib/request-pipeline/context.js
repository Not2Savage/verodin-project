'use strict';

exports.__esModule = true;

var _cookie = require('../utils/cookie');

var _headers = require('./xhr/headers');

var _headers2 = _interopRequireDefault(_headers);

var _charset = require('../processing/encoding/charset');

var _charset2 = _interopRequireDefault(_charset);

var _url = require('../utils/url');

var urlUtils = _interopRequireWildcard(_url);

var _contentType = require('../utils/content-type');

var contentTypeUtils = _interopRequireWildcard(_contentType);

var _generateUniqueId = require('../utils/generate-unique-id');

var _generateUniqueId2 = _interopRequireDefault(_generateUniqueId);

var _sameOriginPolicy = require('./xhr/same-origin-policy');

var _headerTransforms = require('./header-transforms');

var headerTransforms = _interopRequireWildcard(_headerTransforms);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
/*eslint-enable no-unused-vars*/


const REDIRECT_STATUS_CODES = [301, 302, 303, 307, 308];
const CANNOT_BE_USED_WITH_WEB_SOCKET_ERR_MSG = 'The function cannot be used with a WebSocket request.';
class RequestPipelineContext {
    constructor(req, res, serverInfo) {
        this.session = null;
        this.reqBody = null;
        this.dest = null;
        this.destRes = null;
        this.destResBody = null;
        this.hasDestReqErr = false;
        this.isXhr = false;
        this.isFetch = false;
        this.isPage = false;
        this.isHtmlImport = false;
        this.isWebSocket = false;
        this.isIframe = false;
        this.isSpecialPage = false;
        this.isWebSocketConnectionReset = false;
        this.contentInfo = null;
        this.restoringStorages = null;
        this.requestId = (0, _generateUniqueId2.default)();
        this.requestFilterRules = [];
        this.onResponseEventData = [];
        this.reqOpts = null;
        this.nonProcessedDestResBody = null;
        this.goToNextStage = true;
        this.isSameOriginPolicyFailed = false;
        this.serverInfo = serverInfo;
        this.req = req;
        this.res = res;
        const acceptHeader = req.headers['accept'];
        this.isXhr = !!req.headers[_headers2.default.requestMarker];
        this.isFetch = !!req.headers[_headers2.default.fetchRequestCredentials];
        this.isPage = !this.isXhr && !this.isFetch && acceptHeader && contentTypeUtils.isPage(acceptHeader);
        this.parsedClientSyncCookie = req.headers.cookie && (0, _cookie.parseClientSyncCookieStr)(req.headers.cookie);
    }
    // TODO: Rewrite parseProxyUrl instead.
    static _flattenParsedProxyUrl(parsed) {
        if (!parsed) return null;
        const parsedResourceType = urlUtils.parseResourceType(parsed.resourceType);
        const dest = {
            url: parsed.destUrl,
            protocol: parsed.destResourceInfo.protocol,
            host: parsed.destResourceInfo.host,
            hostname: parsed.destResourceInfo.hostname,
            port: parsed.destResourceInfo.port,
            partAfterHost: parsed.destResourceInfo.partAfterHost,
            isIframe: parsedResourceType.isIframe,
            isForm: parsedResourceType.isForm,
            isScript: parsedResourceType.isScript,
            isEventSource: parsedResourceType.isEventSource,
            isHtmlImport: parsedResourceType.isHtmlImport,
            isWebSocket: parsedResourceType.isWebSocket,
            charset: parsed.charset,
            reqOrigin: parsed.reqOrigin
        };
        return { dest, sessionId: parsed.sessionId };
    }
    _getDestFromReferer(parsedReferer) {
        const dest = parsedReferer.dest;
        dest.partAfterHost = this.req.url;
        dest.url = urlUtils.formatUrl(dest);
        return { dest, sessionId: parsedReferer.sessionId };
    }
    _isFileDownload() {
        const contentDisposition = this.destRes.headers['content-disposition'];
        return contentDisposition && contentDisposition.includes('attachment') && contentDisposition.includes('filename');
    }
    _resolveInjectableUrls(injectableUrls) {
        return injectableUrls.map(url => this.serverInfo.domain + url);
    }
    _initRequestNatureInfo() {
        const acceptHeader = this.req.headers['accept'];
        this.isWebSocket = this.dest.isWebSocket;
        this.isHtmlImport = this.dest.isHtmlImport;
        this.isPage = !this.isXhr && !this.isFetch && !this.isWebSocket && acceptHeader && contentTypeUtils.isPage(acceptHeader) || this.isHtmlImport;
        this.isIframe = this.dest.isIframe;
        this.isSpecialPage = urlUtils.isSpecialPage(this.dest.url);
        this.isFileProtocol = this.dest.protocol === 'file:';
    }
    // API
    dispatch(openSessions) {
        const parsedReqUrl = urlUtils.parseProxyUrl(this.req.url);
        const referer = this.req.headers['referer'];
        const parsedReferer = referer && urlUtils.parseProxyUrl(referer);
        // TODO: Remove it after parseProxyURL is rewritten.
        let flattenParsedReqUrl = RequestPipelineContext._flattenParsedProxyUrl(parsedReqUrl);
        const flattenParsedReferer = RequestPipelineContext._flattenParsedProxyUrl(parsedReferer);
        // NOTE: Try to extract the destination from the 'referer' header.
        if (!flattenParsedReqUrl && flattenParsedReferer) flattenParsedReqUrl = this._getDestFromReferer(flattenParsedReferer);
        if (!flattenParsedReqUrl) return false;
        this.session = openSessions.get(flattenParsedReqUrl.sessionId);
        if (!this.session) return false;
        this.dest = flattenParsedReqUrl.dest;
        // Browsers add a leading slash to the pathname part of url (GH-608)
        // For example: url http://www.example.com?gd=GID12082014 will be converted
        // to http://www.example.com/?gd=GID12082014
        this.dest.partAfterHost = (this.dest.partAfterHost[0] === '/' ? '' : '/') + this.dest.partAfterHost;
        this.dest.domain = urlUtils.getDomain(this.dest);
        if (flattenParsedReferer) {
            this.dest.referer = flattenParsedReferer.dest.url;
            this.dest.reqOrigin = flattenParsedReferer.dest.protocol === 'file:' ? flattenParsedReferer.dest.url : urlUtils.getDomain(flattenParsedReferer.dest);
        } else if (this.req.headers[_headers2.default.origin]) this.dest.reqOrigin = this.req.headers[_headers2.default.origin];
        this._initRequestNatureInfo();
        if (this.parsedClientSyncCookie) {
            const clientCookie = this.parsedClientSyncCookie.actual.filter(syncCookie => syncCookie.isClientSync && syncCookie.sid === this.session.id);
            this.session.cookies.setByClient(clientCookie);
        }
        return true;
    }
    buildContentInfo() {
        const contentType = this.destRes.headers['content-type'] || '';
        const accept = this.req.headers['accept'] || '';
        const encoding = this.destRes.headers['content-encoding'];
        if (this.isPage && contentType) this.isPage = !this.isXhr && !this.isFetch && contentTypeUtils.isPage(contentType);
        const isCSS = contentTypeUtils.isCSSResource(contentType, accept);
        const isManifest = contentTypeUtils.isManifest(contentType);
        const isScript = this.dest.isScript || contentTypeUtils.isScriptResource(contentType, accept);
        const isForm = this.dest.isForm;
        const isFormWithEmptyResponse = isForm && this.destRes.statusCode === 204;
        const isRedirect = this.destRes.headers['location'] && REDIRECT_STATUS_CODES.includes(this.destRes.statusCode);
        const requireAssetsProcessing = (isCSS || isScript || isManifest) && this.destRes.statusCode !== 204;
        const isNotModified = this.req.method === 'GET' && this.destRes.statusCode === 304 && !!(this.req.headers['if-modified-since'] || this.req.headers['if-none-match']);
        const requireProcessing = !this.isXhr && !this.isFetch && !isFormWithEmptyResponse && !isRedirect && !isNotModified && (this.isPage || this.isIframe || requireAssetsProcessing);
        const isFileDownload = this._isFileDownload() && !this.dest.isScript;
        const isIframeWithImageSrc = this.isIframe && !this.isPage && /^\s*image\//.test(contentType);
        let charset = null;
        const contentTypeUrlToken = urlUtils.getResourceTypeString({
            isIframe: this.isIframe,
            isForm: isForm,
            isScript: isScript
        });
        // NOTE: We need charset information if we are going to process the resource.
        if (requireProcessing) {
            charset = new _charset2.default();
            if (!charset.fromContentType(contentType)) charset.fromUrl(this.dest.charset);
        }
        if (isFileDownload) this.session.handleFileDownload();
        this.contentInfo = {
            charset,
            requireProcessing,
            isIframeWithImageSrc,
            isCSS,
            isScript,
            isManifest,
            encoding,
            contentTypeUrlToken,
            isFileDownload,
            isNotModified,
            isRedirect
        };
    }
    getInjectableScripts() {
        const taskScript = this.isIframe ? '/iframe-task.js' : '/task.js';
        const scripts = this.session.injectable.scripts.concat(taskScript);
        return this._resolveInjectableUrls(scripts);
    }
    getInjectableStyles() {
        return this._resolveInjectableUrls(this.session.injectable.styles);
    }
    redirect(url) {
        if (this.isWebSocket) throw new Error(CANNOT_BE_USED_WITH_WEB_SOCKET_ERR_MSG);
        const res = this.res;
        res.statusCode = 302;
        res.setHeader('location', url);
        res.end();
    }
    saveNonProcessedDestResBody(value) {
        this.nonProcessedDestResBody = value;
    }
    closeWithError(statusCode, resBody = '') {
        if ('setHeader' in this.res && !this.res.headersSent) {
            this.res.statusCode = statusCode;
            this.res.setHeader('content-type', 'text/html');
            this.res.write(resBody);
        }
        this.res.end();
        this.goToNextStage = false;
    }
    toProxyUrl(url, isCrossDomain, resourceType, charset) {
        const proxyHostname = this.serverInfo.hostname;
        const proxyProtocol = this.serverInfo.protocol;
        const proxyPort = isCrossDomain ? this.serverInfo.crossDomainPort : this.serverInfo.port;
        const sessionId = this.session.id;
        return urlUtils.getProxyUrl(url, {
            proxyHostname,
            proxyProtocol,
            proxyPort,
            sessionId,
            resourceType,
            charset
        });
    }
    isPassSameOriginPolicy() {
        const isAjaxRequest = this.isXhr || this.isFetch;
        const shouldPerformCORSCheck = isAjaxRequest && !this.contentInfo.isNotModified;
        return !shouldPerformCORSCheck || (0, _sameOriginPolicy.check)(this);
    }
    forEachRequestFilterRule(fn) {
        var _this = this;

        return _asyncToGenerator(function* () {
            yield Promise.all(_this.requestFilterRules.map(fn));
        })();
    }
    sendResponseHeaders() {
        if (this.isWebSocket) throw new Error(CANNOT_BE_USED_WITH_WEB_SOCKET_ERR_MSG);
        const headers = headerTransforms.forResponse(this);
        const res = this.res;
        res.writeHead(this.destRes.statusCode, headers);
        res.addTrailers(this.destRes.trailers);
    }
    mockResponse() {
        this.mock.setRequestOptions(this.reqOpts);
        this.destRes = this.mock.getResponse();
    }
    setupMockIfNecessary(rule) {
        const mock = this.session.getMock(rule);
        if (mock && !this.mock) this.mock = mock;
    }
    isDestResBodyMalformed() {
        return !this.destResBody || this.destResBody.length.toString() !== this.destRes.headers['content-length'];
    }
    getOnResponseEventData({ includeBody }) {
        return this.onResponseEventData.filter(eventData => eventData.opts.includeBody === includeBody);
    }
}
exports.default = RequestPipelineContext;
module.exports = exports['default'];