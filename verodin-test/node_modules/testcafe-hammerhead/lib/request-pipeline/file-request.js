'use strict';

exports.__esModule = true;

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _mime = require('mime');

var _mime2 = _interopRequireDefault(_mime);

var _events = require('events');

var _url = require('url');

var _messages = require('../messages');

var _promisifiedFunctions = require('../utils/promisified-functions');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DISK_RE = /^\/[A-Za-z]:/;
const TARGET_IS_NOT_FILE = 'The target of the operation is not a file';
class FileRequest extends _events.EventEmitter {
    constructor(opts) {
        super();
        this.url = opts.url;
        this.path = FileRequest._getPath(opts.url);
        this._initEvents();
    }
    _initEvents() {
        (0, _promisifiedFunctions.stat)(this.path).then(stats => {
            if (!stats.isFile()) throw new Error(TARGET_IS_NOT_FILE);
            return (0, _promisifiedFunctions.access)(this.path, _fs2.default.constants.R_OK);
        }).then(() => this._onOpen()).catch(err => this._onError(err));
    }
    static _getPath(proxiedUrl) {
        const parsedUrl = (0, _url.parse)(proxiedUrl);
        let path = decodeURIComponent(parsedUrl.pathname);
        if (DISK_RE.test(path)) path = path.substr(1);
        return path;
    }
    _onError(err) {
        this.emit('fatalError', (0, _messages.getText)(_messages.MESSAGE.cantReadFile, this.url, err.message));
    }
    _onOpen() {
        let stream = _fs2.default.createReadStream(this.path);
        stream = Object.assign(stream, {
            statusCode: 200,
            trailers: {},
            headers: {
                'content-type': _mime2.default.lookup(this.path)
            }
        });
        this.emit('response', stream);
    }
}
exports.default = FileRequest;
module.exports = exports['default'];