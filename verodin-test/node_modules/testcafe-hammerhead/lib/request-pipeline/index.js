'use strict';

exports.__esModule = true;
exports.run = undefined;

let run = exports.run = (() => {
    var _ref13 = _asyncToGenerator(function* (req, res, serverInfo, openSessions) {
        const ctx = new _context2.default(req, res, serverInfo);
        if (!ctx.dispatch(openSessions)) {
            (0, _http.respond404)(res);
            return;
        }
        for (let i = 0; i < stages.length; i++) {
            yield stages[i](ctx);
            if (!ctx.goToNextStage) return;
        }
    });

    return function run(_x12, _x13, _x14, _x15) {
        return _ref13.apply(this, arguments);
    };
})();

var _context = require('./context');

var _context2 = _interopRequireDefault(_context);

var _resources = require('../processing/resources');

var _messages = require('../messages');

var _connectionResetGuard = require('./connection-reset-guard');

var _connectionResetGuard2 = _interopRequireDefault(_connectionResetGuard);

var _sameOriginCheckFailedStatusCode = require('./xhr/same-origin-check-failed-status-code');

var _sameOriginCheckFailedStatusCode2 = _interopRequireDefault(_sameOriginCheckFailedStatusCode);

var _http = require('../utils/http');

var _websocket = require('./websocket');

var _specialPage = require('./special-page');

var _specialPage2 = _interopRequireDefault(_specialPage);

var _info = require('../session/events/info');

var _names = require('../session/events/names');

var _names2 = _interopRequireDefault(_names);

var _configureResponseEvent = require('../session/events/configure-response-event');

var _configureResponseEvent2 = _interopRequireDefault(_configureResponseEvent);

var _configureResponseEventOptions = require('../session/events/configure-response-event-options');

var _configureResponseEventOptions2 = _interopRequireDefault(_configureResponseEventOptions);

var _lodash = require('lodash');

var _utils = require('./utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; } /*eslint-enable no-unused-vars*/


const EVENT_SOURCE_REQUEST_TIMEOUT = 60 * 60 * 1000;
const stages = [function handleSocketError(ctx) {
    // NOTE: In some case on MacOS, browser reset connection with server and we need to catch this exception.
    if (!ctx.isWebSocket) return;
    ctx.res.on('error', e => {
        // @ts-ignore
        if (e.code === 'ECONNRESET' && !ctx.mock) {
            if (ctx.destRes) ctx.destRes.destroy();else ctx.isWebSocketConnectionReset = true;
        } else throw e;
    });
}, (() => {
    var _ref = _asyncToGenerator(function* (ctx) {
        if (ctx.isPage && !ctx.isIframe && !ctx.isHtmlImport) ctx.session.onPageRequest(ctx);
        ctx.reqBody = yield (0, _http.fetchBody)(ctx.req);
    });

    function fetchProxyRequestBody(_x) {
        return _ref.apply(this, arguments);
    }

    return fetchProxyRequestBody;
})(), (() => {
    var _ref2 = _asyncToGenerator(function* (ctx) {
        if (ctx.isSpecialPage) {
            ctx.destRes = (0, _specialPage2.default)();
            return;
        }
        ctx.reqOpts = new _utils.ReqOpts(ctx);
        if (ctx.session.hasRequestEventListeners()) {
            const requestInfo = new _info.RequestInfo(ctx, ctx.reqOpts);
            ctx.requestFilterRules = ctx.session.getRequestFilterRules(requestInfo);
            yield ctx.forEachRequestFilterRule((() => {
                var _ref3 = _asyncToGenerator(function* (rule) {
                    yield (0, _utils.callOnRequestEventCallback)(ctx, rule, requestInfo);
                    ctx.setupMockIfNecessary(rule);
                });

                return function (_x3) {
                    return _ref3.apply(this, arguments);
                };
            })());
        }
        if (ctx.mock) ctx.mockResponse();else yield (0, _utils.sendRequest)(ctx);
    });

    function sendDestinationRequest(_x2) {
        return _ref2.apply(this, arguments);
    }

    return sendDestinationRequest;
})(), (() => {
    var _ref4 = _asyncToGenerator(function* (ctx) {
        ctx.buildContentInfo();
        if (ctx.isPassSameOriginPolicy()) return;
        ctx.isSameOriginPolicyFailed = true;
        yield ctx.forEachRequestFilterRule((() => {
            var _ref5 = _asyncToGenerator(function* (rule) {
                const configureResponseEvent = new _configureResponseEvent2.default(ctx, rule, _configureResponseEventOptions2.default.DEFAULT);
                yield ctx.session.callRequestEventCallback(_names2.default.onConfigureResponse, rule, configureResponseEvent);
                yield (0, _utils.callOnResponseEventCallbackForFailedSameOriginCheck)(ctx, rule, configureResponseEvent);
            });

            return function (_x5) {
                return _ref5.apply(this, arguments);
            };
        })());
        ctx.closeWithError(_sameOriginCheckFailedStatusCode2.default);
    });

    function checkSameOriginPolicyCompliance(_x4) {
        return _ref4.apply(this, arguments);
    }

    return checkSameOriginPolicyCompliance;
})(), (() => {
    var _ref6 = _asyncToGenerator(function* (ctx) {
        ctx.goToNextStage = false;
        if (ctx.isWebSocket) {
            (0, _websocket.respondOnWebSocket)(ctx);
            return;
        }
        if (ctx.contentInfo.requireProcessing && ctx.destRes.statusCode === 204) ctx.destRes.statusCode = 200;
        // NOTE: Just pipe the content body to the browser if we don't need to process it.
        else if (!ctx.contentInfo.requireProcessing) {
                if (!ctx.isSpecialPage) {
                    yield (0, _utils.callOnConfigureResponseEventForNonProcessedRequest)(ctx);
                    ctx.sendResponseHeaders();
                    if (ctx.contentInfo.isNotModified) yield (0, _utils.callOnResponseEventCallbackForMotModifiedResource)(ctx);else {
                        const onResponseEventDataWithBody = ctx.getOnResponseEventData({ includeBody: true });
                        const onResponseEventDataWithoutBody = ctx.getOnResponseEventData({ includeBody: false });
                        if (onResponseEventDataWithBody.length) yield (0, _utils.callOnResponseEventCallbackWithBodyForNonProcessedRequest)(ctx, onResponseEventDataWithBody);else if (onResponseEventDataWithoutBody.length) yield (0, _utils.callOnResponseEventCallbackWithoutBodyForNonProcessedResource)(ctx, onResponseEventDataWithoutBody);else ctx.destRes.pipe(ctx.res);
                    }
                    // NOTE: sets 60 minutes timeout for the "event source" requests instead of 2 minutes by default
                    if (ctx.dest.isEventSource) {
                        ctx.req.setTimeout(EVENT_SOURCE_REQUEST_TIMEOUT, _lodash.noop);
                        ctx.req.on('close', function () {
                            return ctx.destRes.destroy();
                        });
                    }
                } else {
                    ctx.sendResponseHeaders();
                    ctx.res.end();
                }
                return;
            }
        ctx.goToNextStage = true;
    });

    function decideOnProcessingStrategy(_x6) {
        return _ref6.apply(this, arguments);
    }

    return decideOnProcessingStrategy;
})(), (() => {
    var _ref7 = _asyncToGenerator(function* (ctx) {
        ctx.destResBody = yield (0, _http.fetchBody)(ctx.destRes);
        if (ctx.requestFilterRules.length) ctx.saveNonProcessedDestResBody(ctx.destResBody);
        // NOTE: Sometimes the underlying socket emits an error event. But if we have a response body,
        // we can still process such requests. (B234324)
        if (ctx.hasDestReqErr && ctx.isDestResBodyMalformed()) {
            (0, _utils.error)(ctx, (0, _messages.getText)(_messages.MESSAGE.destConnectionTerminated, ctx.dest.url));
            ctx.goToNextStage = false;
        }
    });

    function fetchContent(_x7) {
        return _ref7.apply(this, arguments);
    }

    return fetchContent;
})(), (() => {
    var _ref8 = _asyncToGenerator(function* (ctx) {
        try {
            ctx.destResBody = yield (0, _resources.process)(ctx);
        } catch (err) {
            (0, _utils.error)(ctx, err);
        }
    });

    function processContent(_x8) {
        return _ref8.apply(this, arguments);
    }

    return processContent;
})(), (() => {
    var _ref9 = _asyncToGenerator(function* (ctx) {
        const configureResponseEvents = yield Promise.all(ctx.requestFilterRules.map((() => {
            var _ref10 = _asyncToGenerator(function* (rule) {
                const configureResponseEvent = new _configureResponseEvent2.default(ctx, rule, _configureResponseEventOptions2.default.DEFAULT);
                yield ctx.session.callRequestEventCallback(_names2.default.onConfigureResponse, rule, configureResponseEvent);
                return configureResponseEvent;
            });

            return function (_x10) {
                return _ref10.apply(this, arguments);
            };
        })()));
        ctx.sendResponseHeaders();
        (0, _connectionResetGuard2.default)(_asyncToGenerator(function* () {
            yield Promise.all(configureResponseEvents.map((() => {
                var _ref12 = _asyncToGenerator(function* (configureResponseEvent) {
                    yield (0, _utils.callResponseEventCallbackForProcessedRequest)(ctx, configureResponseEvent);
                });

                return function (_x11) {
                    return _ref12.apply(this, arguments);
                };
            })()));
            const res = ctx.res;
            res.write(ctx.destResBody);
            ctx.res.end();
        }));
    });

    function sendProxyResponse(_x9) {
        return _ref9.apply(this, arguments);
    }

    return sendProxyResponse;
})()];