'use strict';

exports.__esModule = true;
exports.callOnResponseEventCallbackForMotModifiedResource = exports.callOnResponseEventCallbackWithoutBodyForNonProcessedResource = exports.callOnResponseEventCallbackWithBodyForNonProcessedRequest = exports.callOnConfigureResponseEventForNonProcessedRequest = exports.callOnResponseEventCallbackForFailedSameOriginCheck = exports.callOnRequestEventCallback = exports.callResponseEventCallbackForProcessedRequest = exports.ReqOpts = undefined;

let callResponseEventCallbackForProcessedRequest = exports.callResponseEventCallbackForProcessedRequest = (() => {
    var _ref = _asyncToGenerator(function* (ctx, configureResponseEvent) {
        const responseInfo = new _info.ResponseInfo(ctx);
        const preparedResponseInfo = new _info.PreparedResponseInfo(responseInfo, configureResponseEvent.opts);
        const responseEvent = new _responseEvent2.default(configureResponseEvent._requestFilterRule, preparedResponseInfo);
        yield ctx.session.callRequestEventCallback(_names2.default.onResponse, configureResponseEvent._requestFilterRule, responseEvent);
    });

    return function callResponseEventCallbackForProcessedRequest(_x, _x2) {
        return _ref.apply(this, arguments);
    };
})();

let callOnRequestEventCallback = exports.callOnRequestEventCallback = (() => {
    var _ref2 = _asyncToGenerator(function* (ctx, rule, reqInfo) {
        const requestEvent = new _requestEvent2.default(ctx, rule, reqInfo);
        yield ctx.session.callRequestEventCallback(_names2.default.onRequest, rule, requestEvent);
    });

    return function callOnRequestEventCallback(_x3, _x4, _x5) {
        return _ref2.apply(this, arguments);
    };
})();

let callOnResponseEventCallbackForFailedSameOriginCheck = exports.callOnResponseEventCallbackForFailedSameOriginCheck = (() => {
    var _ref3 = _asyncToGenerator(function* (ctx, rule, configureOpts) {
        const responseInfo = new _info.ResponseInfo(ctx);
        const preparedResponseInfo = new _info.PreparedResponseInfo(responseInfo, configureOpts);
        const responseEvent = new _responseEvent2.default(rule, preparedResponseInfo);
        yield ctx.session.callRequestEventCallback(_names2.default.onResponse, rule, responseEvent);
    });

    return function callOnResponseEventCallbackForFailedSameOriginCheck(_x6, _x7, _x8) {
        return _ref3.apply(this, arguments);
    };
})();

let callOnConfigureResponseEventForNonProcessedRequest = exports.callOnConfigureResponseEventForNonProcessedRequest = (() => {
    var _ref4 = _asyncToGenerator(function* (ctx) {
        yield ctx.forEachRequestFilterRule((() => {
            var _ref5 = _asyncToGenerator(function* (rule) {
                const configureResponseEvent = new _configureResponseEvent2.default(ctx, rule, _configureResponseEventOptions2.default.DEFAULT);
                yield ctx.session.callRequestEventCallback(_names2.default.onConfigureResponse, rule, configureResponseEvent);
                ctx.onResponseEventData.push({ rule, opts: configureResponseEvent.opts });
            });

            return function (_x10) {
                return _ref5.apply(this, arguments);
            };
        })());
    });

    return function callOnConfigureResponseEventForNonProcessedRequest(_x9) {
        return _ref4.apply(this, arguments);
    };
})();

let callOnResponseEventCallbackWithBodyForNonProcessedRequest = exports.callOnResponseEventCallbackWithBodyForNonProcessedRequest = (() => {
    var _ref6 = _asyncToGenerator(function* (ctx, onResponseEventDataWithBody) {
        const destResBodyCollectorStream = new _stream.PassThrough();
        ctx.destRes.pipe(destResBodyCollectorStream);
        (0, _promisifyStream2.default)(destResBodyCollectorStream).then((() => {
            var _ref7 = _asyncToGenerator(function* (data) {
                ctx.saveNonProcessedDestResBody(data);
                const responseInfo = new _info.ResponseInfo(ctx);
                yield Promise.all(onResponseEventDataWithBody.map((() => {
                    var _ref8 = _asyncToGenerator(function* ({ rule, opts }) {
                        const preparedResponseInfo = new _info.PreparedResponseInfo(responseInfo, opts);
                        const responseEvent = new _responseEvent2.default(rule, preparedResponseInfo);
                        yield ctx.session.callRequestEventCallback(_names2.default.onResponse, rule, responseEvent);
                    });

                    return function (_x14) {
                        return _ref8.apply(this, arguments);
                    };
                })()));
                (0, _buffer.toReadableStream)(data).pipe(ctx.res);
            });

            return function (_x13) {
                return _ref7.apply(this, arguments);
            };
        })());
    });

    return function callOnResponseEventCallbackWithBodyForNonProcessedRequest(_x11, _x12) {
        return _ref6.apply(this, arguments);
    };
})();

let callOnResponseEventCallbackWithoutBodyForNonProcessedResource = exports.callOnResponseEventCallbackWithoutBodyForNonProcessedResource = (() => {
    var _ref9 = _asyncToGenerator(function* (ctx, onResponseEventDataWithoutBody) {
        const responseInfo = new _info.ResponseInfo(ctx);
        yield Promise.all(onResponseEventDataWithoutBody.map((() => {
            var _ref10 = _asyncToGenerator(function* (item) {
                const preparedResponseInfo = new _info.PreparedResponseInfo(responseInfo, item.opts);
                const responseEvent = new _responseEvent2.default(item.rule, preparedResponseInfo);
                yield ctx.session.callRequestEventCallback(_names2.default.onResponse, item.rule, responseEvent);
            });

            return function (_x17) {
                return _ref10.apply(this, arguments);
            };
        })()));
        ctx.destRes.pipe(ctx.res);
    });

    return function callOnResponseEventCallbackWithoutBodyForNonProcessedResource(_x15, _x16) {
        return _ref9.apply(this, arguments);
    };
})();

let callOnResponseEventCallbackForMotModifiedResource = exports.callOnResponseEventCallbackForMotModifiedResource = (() => {
    var _ref11 = _asyncToGenerator(function* (ctx) {
        const responseInfo = new _info.ResponseInfo(ctx);
        yield Promise.all(ctx.onResponseEventData.map((() => {
            var _ref12 = _asyncToGenerator(function* (item) {
                const preparedResponseInfo = new _info.PreparedResponseInfo(responseInfo, item.opts);
                const responseEvent = new _responseEvent2.default(item.rule, preparedResponseInfo);
                yield ctx.session.callRequestEventCallback(_names2.default.onResponse, item.rule, responseEvent);
            });

            return function (_x19) {
                return _ref12.apply(this, arguments);
            };
        })()));
        ctx.res.end();
    });

    return function callOnResponseEventCallbackForMotModifiedResource(_x18) {
        return _ref11.apply(this, arguments);
    };
})();

exports.sendRequest = sendRequest;
exports.error = error;

var _fileRequest = require('./file-request');

var _fileRequest2 = _interopRequireDefault(_fileRequest);

var _upload = require('../upload');

var _matchUrlWildcard = require('match-url-wildcard');

var _matchUrlWildcard2 = _interopRequireDefault(_matchUrlWildcard);

var _headerTransforms = require('./header-transforms');

var headerTransforms = _interopRequireWildcard(_headerTransforms);

var _destinationRequest = require('./destination-request');

var _destinationRequest2 = _interopRequireDefault(_destinationRequest);

var _info = require('../session/events/info');

var _promisifyStream = require('../utils/promisify-stream');

var _promisifyStream2 = _interopRequireDefault(_promisifyStream);

var _configureResponseEvent = require('../session/events/configure-response-event');

var _configureResponseEvent2 = _interopRequireDefault(_configureResponseEvent);

var _requestEvent = require('../session/events/request-event');

var _requestEvent2 = _interopRequireDefault(_requestEvent);

var _responseEvent = require('../session/events/response-event');

var _responseEvent2 = _interopRequireDefault(_responseEvent);

var _names = require('../session/events/names');

var _names2 = _interopRequireDefault(_names);

var _configureResponseEventOptions = require('../session/events/configure-response-event-options');

var _configureResponseEventOptions2 = _interopRequireDefault(_configureResponseEventOptions);

var _buffer = require('../utils/buffer');

var _stream = require('stream');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
/*eslint-enable no-unused-vars*/


class ReqOpts {
    constructor(ctx) {
        const bodyWithUploads = (0, _upload.inject)(ctx.req.headers['content-type'], ctx.reqBody);
        // NOTE: First, we should rewrite the request body, because the 'content-length' header will be built based on it.
        if (bodyWithUploads) ctx.reqBody = bodyWithUploads;
        // NOTE: All headers, including 'content-length', are built here.
        const headers = headerTransforms.forRequest(ctx);
        const proxy = ctx.session.externalProxySettings;
        this.url = ctx.dest.url;
        this.protocol = ctx.dest.protocol;
        this.hostname = ctx.dest.hostname;
        this.host = ctx.dest.host;
        this.port = ctx.dest.port;
        this.path = ctx.dest.partAfterHost;
        this.method = ctx.req.method;
        this.credentials = ctx.session.getAuthCredentials();
        this.body = ctx.reqBody;
        this.isXhr = ctx.isXhr;
        this.rawHeaders = ctx.req.rawHeaders;
        this.headers = headers;
        if (proxy && !(0, _matchUrlWildcard2.default)(ctx.dest.url, proxy.bypassRules)) {
            this.proxy = proxy;
            if (ctx.dest.protocol === 'http:') {
                this.path = this.protocol + '//' + this.host + this.path;
                this.host = proxy.host;
                this.hostname = proxy.hostname;
                this.port = proxy.port;
                if (proxy.authHeader) headers['proxy-authorization'] = proxy.authHeader;
            }
        }
    }
}
exports.ReqOpts = ReqOpts;
function sendRequest(ctx) {
    return new Promise(resolve => {
        const req = ctx.isFileProtocol ? new _fileRequest2.default(ctx.reqOpts) : new _destinationRequest2.default(ctx.reqOpts);
        ctx.goToNextStage = false;
        req.on('response', res => {
            if (ctx.isWebSocketConnectionReset) {
                res.destroy();
                resolve();
            }
            ctx.destRes = res;
            ctx.goToNextStage = true;
            resolve();
        });
        req.on('error', () => {
            ctx.hasDestReqErr = true;
            resolve();
        });
        req.on('fatalError', err => {
            error(ctx, err);
            resolve();
        });
        req.on('socketHangUp', () => {
            ctx.req.socket.end();
            resolve();
        });
    });
}
function error(ctx, err) {
    if (ctx.isPage && !ctx.isIframe) ctx.session.handlePageError(ctx, err);else if (ctx.isFetch || ctx.isXhr) ctx.req.destroy();else ctx.closeWithError(500, err.toString());
}