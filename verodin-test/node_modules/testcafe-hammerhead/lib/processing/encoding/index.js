'use strict';

exports.__esModule = true;
exports.encodeContent = exports.decodeContent = undefined;

// NOTE: IIS has a bug when it sends 'raw deflate' compressed data for the 'Deflate' Accept-Encoding header.
// (see: http://zoompf.com/2012/02/lose-the-wait-http-compression)
let inflateWithFallback = (() => {
    var _ref = _asyncToGenerator(function* (data) {
        try {
            return yield (0, _promisifiedFunctions.inflate)(data);
        } catch (err) {
            if (err.code === 'Z_DATA_ERROR') return yield (0, _promisifiedFunctions.inflateRaw)(data);
            throw err;
        }
    });

    return function inflateWithFallback(_x) {
        return _ref.apply(this, arguments);
    };
})();

let decodeContent = exports.decodeContent = (() => {
    var _ref2 = _asyncToGenerator(function* (content, encoding, charset) {
        if (encoding === GZIP_CONTENT_ENCODING) {
            // NOTE: https://github.com/request/request/pull/2492/files
            // Be more lenient with decoding compressed responses, since (very rarely)
            // servers send slightly invalid gzip responses that are still accepted
            // by common browsers.
            // Always using Z_SYNC_FLUSH is what cURL does.
            // GH-1915
            content = yield (0, _promisifiedFunctions.gunzip)(content, { flush: _zlib2.default.Z_SYNC_FLUSH, finishFlush: _zlib2.default.Z_SYNC_FLUSH });
        } else if (encoding === DEFLATE_CONTENT_ENCODING) content = yield inflateWithFallback(content);else if (encoding === BROTLI_CONTENT_ENCODING) content = Buffer.from(require('brotli').decompress(content));
        charset.fromBOM(content);
        return _iconvLite2.default.decode(content, charset.get());
    });

    return function decodeContent(_x2, _x3, _x4) {
        return _ref2.apply(this, arguments);
    };
})();

let encodeContent = exports.encodeContent = (() => {
    var _ref3 = _asyncToGenerator(function* (content, encoding, charset) {
        content = _iconvLite2.default.encode(content, charset.get(), { addBOM: charset.isFromBOM() });
        if (encoding === GZIP_CONTENT_ENCODING) return (0, _promisifiedFunctions.gzip)(content);
        if (encoding === DEFLATE_CONTENT_ENCODING) return (0, _promisifiedFunctions.deflate)(content);
        if (encoding === BROTLI_CONTENT_ENCODING) return Buffer.from(require('brotli').compress(content));
        return content;
    });

    return function encodeContent(_x5, _x6, _x7) {
        return _ref3.apply(this, arguments);
    };
})();

var _zlib = require('zlib');

var _zlib2 = _interopRequireDefault(_zlib);

var _promisifiedFunctions = require('../../utils/promisified-functions');

var _iconvLite = require('iconv-lite');

var _iconvLite2 = _interopRequireDefault(_iconvLite);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const GZIP_CONTENT_ENCODING = 'gzip';
const DEFLATE_CONTENT_ENCODING = 'deflate';
const BROTLI_CONTENT_ENCODING = 'br';