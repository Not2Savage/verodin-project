'use strict';

exports.__esModule = true;

var _dedent = require('dedent');

var _dedent2 = _interopRequireDefault(_dedent);

var _lodash = require('lodash');

var _types = require('../types');

var _renderForbiddenCharsList = require('../render-forbidden-chars-list');

var _renderForbiddenCharsList2 = _interopRequireDefault(_renderForbiddenCharsList);

var _string = require('../../utils/string');

var _phase = require('../../test-run/phase');

var _phase2 = _interopRequireDefault(_phase);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const SUBTITLES = {
    [_phase2.default.initial]: '',
    [_phase2.default.inFixtureBeforeHook]: '<span class="subtitle">Error in fixture.before hook</span>\n',
    [_phase2.default.inFixtureBeforeEachHook]: '<span class="subtitle">Error in fixture.beforeEach hook</span>\n',
    [_phase2.default.inTestBeforeHook]: '<span class="subtitle">Error in test.before hook</span>\n',
    [_phase2.default.inTest]: '',
    [_phase2.default.inTestAfterHook]: '<span class="subtitle">Error in test.after hook</span>\n',
    [_phase2.default.inFixtureAfterEachHook]: '<span class="subtitle">Error in fixture.afterEach hook</span>\n',
    [_phase2.default.inFixtureAfterHook]: '<span class="subtitle">Error in fixture.after hook</span>\n',
    [_phase2.default.inRoleInitializer]: '<span class="subtitle">Error in Role initializer</span>\n',
    [_phase2.default.inBookmarkRestore]: '<span class="subtitle">Error while restoring configuration after Role switch</span>\n'
};

const EXTERNAL_LINKS = {
    createNewIssue: 'https://github.com/DevExpress/testcafe/issues/new?template=bug-report.md',
    viewportSizes: 'http://viewportsizes.com'
};

function formatUrl(url) {
    return `<a href="${url}">${url}</a>`;
}

function formatSelectorCallstack(apiFnChain, apiFnIndex, viewportWidth) {
    if (typeof apiFnIndex === 'undefined') return '';

    const emptySpaces = 10;
    const ellipsis = '...)';
    const availableWidth = viewportWidth - emptySpaces;

    return apiFnChain.map((apiFn, index) => {
        let formattedApiFn = String.fromCharCode(160);

        formattedApiFn += index === apiFnIndex ? '>' : ' ';
        formattedApiFn += ' | ';
        formattedApiFn += index !== 0 ? '  ' : '';
        formattedApiFn += apiFn;

        if (formattedApiFn.length > availableWidth) return formattedApiFn.substr(0, availableWidth - emptySpaces) + ellipsis;

        return formattedApiFn;
    }).join('\n');
}

function markup(err, msgMarkup, opts = {}) {
    msgMarkup = (0, _dedent2.default)(`
        ${SUBTITLES[err.testRunPhase]}<div class="message">${(0, _dedent2.default)(msgMarkup)}</div>

        <strong>Browser:</strong> <span class="user-agent">${err.userAgent}</span>
    `);

    if (err.screenshotPath) msgMarkup += `\n<div class="screenshot-info"><strong>Screenshot:</strong> <a class="screenshot-path">${(0, _lodash.escape)(err.screenshotPath)}</a></div>`;

    if (!opts.withoutCallsite) {
        const callsiteMarkup = err.getCallsiteMarkup();

        if (callsiteMarkup) msgMarkup += `\n\n${callsiteMarkup}`;
    }

    return msgMarkup.replace('\t', '&nbsp;'.repeat(4));
}

exports.default = {
    [_types.TEST_RUN_ERRORS.actionIntegerOptionError]: err => markup(err, `
        The "${err.optionName}" option is expected to be an integer, but it was ${err.actualValue}.
    `),

    [_types.TEST_RUN_ERRORS.actionPositiveIntegerOptionError]: err => markup(err, `
        The "${err.optionName}" option is expected to be a positive integer, but it was ${err.actualValue}.
    `),

    [_types.TEST_RUN_ERRORS.actionBooleanOptionError]: err => markup(err, `
        The "${err.optionName}" option is expected to be a boolean value, but it was ${err.actualValue}.
    `),

    [_types.TEST_RUN_ERRORS.actionSpeedOptionError]: err => markup(err, `
        The "${err.optionName}" option is expected to be a number between 0.01 and 1, but it was ${err.actualValue}.
    `),

    [_types.TEST_RUN_ERRORS.pageLoadError]: err => markup(err, `
        ${err.errMsg}
    `),

    [_types.TEST_RUN_ERRORS.uncaughtErrorOnPage]: err => markup(err, `
        A JavaScript error occurred on ${formatUrl(err.pageDestUrl)}.
        At this moment, TestCafe tracks uncaught JavaScript errors on the page. Try to manually perform the test scenario.
        If this error still occurs then it means you site has uncaught JavaScript errors. To disable JavaScript error tracking you can turn the --skip-js-errors option on.
        If the error occurs only with TestCafe then it is a bug. Write a new issue about it at:
        ${formatUrl(EXTERNAL_LINKS.createNewIssue)}.

        JavaScript error details:
        ${(0, _string.replaceLeadingSpacesWithNbsp)((0, _lodash.escape)(err.errStack))}
    `),

    [_types.TEST_RUN_ERRORS.uncaughtErrorInTestCode]: err => markup(err, `
        ${(0, _lodash.escape)(err.errMsg)}
    `),

    [_types.TEST_RUN_ERRORS.nativeDialogNotHandledError]: err => markup(err, `
        A native ${err.dialogType} dialog was invoked on page ${formatUrl(err.pageUrl)}, but no handler was set for it. Use the "setNativeDialogHandler" function to introduce a handler function for native dialogs.
    `),

    [_types.TEST_RUN_ERRORS.nativeDialogNotHandledError]: err => markup(err, `
        A native ${err.dialogType} dialog was invoked on page <a href="${err.pageUrl}">${err.pageUrl}</a>, but no handler was set for it. Use the "setNativeDialogHandler" function to introduce a handler function for native dialogs.
    `),

    [_types.TEST_RUN_ERRORS.uncaughtErrorInNativeDialogHandler]: err => markup(err, `
        An error occurred in the native dialog handler called for a native ${err.dialogType} dialog on page <a href="${err.pageUrl}">${err.pageUrl}</a>:

        ${(0, _lodash.escape)(err.errMsg)}
    `),

    [_types.TEST_RUN_ERRORS.setTestSpeedArgumentError]: err => markup(err, `
        Speed is expected to be a number between 0.01 and 1, but ${err.actualValue} was passed.
    `),

    [_types.TEST_RUN_ERRORS.setNativeDialogHandlerCodeWrongTypeError]: err => markup(err, `
        The native dialog handler is expected to be a function, ClientFunction or null, but it was ${err.actualType}.
    `),

    [_types.TEST_RUN_ERRORS.uncaughtErrorInClientFunctionCode]: err => markup(err, `
        An error occurred in ${err.instantiationCallsiteName} code:

        ${(0, _lodash.escape)(err.errMsg)}
    `),

    [_types.TEST_RUN_ERRORS.uncaughtErrorInCustomDOMPropertyCode]: err => markup(err, `
        An error occurred when trying to calculate a custom Selector property "${err.property}":

        ${(0, _lodash.escape)(err.errMsg)}
    `),

    [_types.TEST_RUN_ERRORS.clientFunctionExecutionInterruptionError]: err => markup(err, `
        ${err.instantiationCallsiteName} execution was interrupted by page unload. This problem may appear if you trigger page navigation from ${err.instantiationCallsiteName} code.
    `),

    [_types.TEST_RUN_ERRORS.uncaughtNonErrorObjectInTestCode]: err => markup(err, `
        Uncaught ${err.objType} "${(0, _lodash.escape)(err.objStr)}" was thrown. Throw Error instead.
    `, { withoutCallsite: true }),

    [_types.TEST_RUN_ERRORS.unhandledPromiseRejection]: err => markup(err, `
        Unhandled promise rejection:

        ${(0, _lodash.escape)(err.errMsg)}
    `, { withoutCallsite: true }),

    [_types.TEST_RUN_ERRORS.uncaughtException]: err => markup(err, `
        Uncaught exception:

        ${(0, _lodash.escape)(err.errMsg)}
    `, { withoutCallsite: true }),

    [_types.TEST_RUN_ERRORS.actionOptionsTypeError]: err => markup(err, `
        Action options is expected to be an object, null or undefined but it was ${err.actualType}.
    `),

    [_types.TEST_RUN_ERRORS.actionStringArgumentError]: err => markup(err, `
        The "${err.argumentName}" argument is expected to be a non-empty string, but it was ${err.actualValue}.
    `),

    [_types.TEST_RUN_ERRORS.actionBooleanArgumentError]: err => markup(err, `
        The "${err.argumentName}" argument is expected to be a boolean value, but it was ${err.actualValue}.
    `),

    [_types.TEST_RUN_ERRORS.actionNullableStringArgumentError]: err => markup(err, `
        The "${err.argumentName}" argument is expected to be a null or a string, but it was ${err.actualValue}.
    `),

    [_types.TEST_RUN_ERRORS.actionStringOrStringArrayArgumentError]: err => markup(err, `
        The "${err.argumentName}" argument is expected to be a non-empty string or a string array, but it was ${err.actualValue}.
    `),

    [_types.TEST_RUN_ERRORS.actionStringArrayElementError]: err => markup(err, `
        Elements of the "${err.argumentName}" argument are expected to be non-empty strings, but the element at index ${err.elementIndex} was ${err.actualValue}.
    `),

    [_types.TEST_RUN_ERRORS.actionIntegerArgumentError]: err => markup(err, `
        The "${err.argumentName}" argument is expected to be an integer, but it was ${err.actualValue}.
    `),

    [_types.TEST_RUN_ERRORS.actionRoleArgumentError]: err => markup(err, `
        The "${err.argumentName}" argument is expected to be a Role instance, but it was ${err.actualValue}.
    `),

    [_types.TEST_RUN_ERRORS.actionPositiveIntegerArgumentError]: err => markup(err, `
        The "${err.argumentName}" argument is expected to be a positive integer, but it was ${err.actualValue}.
    `),

    [_types.TEST_RUN_ERRORS.actionElementNotFoundError]: (err, viewportWidth) => markup(err, `
        The specified selector does not match any element in the DOM tree.

        ${formatSelectorCallstack(err.apiFnChain, err.apiFnIndex, viewportWidth)}
    `),

    [_types.TEST_RUN_ERRORS.actionElementIsInvisibleError]: err => markup(err, `
        The element that matches the specified selector is not visible.
    `),

    [_types.TEST_RUN_ERRORS.actionSelectorMatchesWrongNodeTypeError]: err => markup(err, `
        The specified selector is expected to match a DOM element, but it matches a ${err.nodeDescription} node.
    `),

    [_types.TEST_RUN_ERRORS.actionAdditionalElementNotFoundError]: (err, viewportWidth) => markup(err, `
        The specified "${err.argumentName}" does not match any element in the DOM tree.

        ${formatSelectorCallstack(err.apiFnChain, err.apiFnIndex, viewportWidth)}
    `),

    [_types.TEST_RUN_ERRORS.actionAdditionalElementIsInvisibleError]: err => markup(err, `
        The element that matches the specified "${err.argumentName}" is not visible.
    `),

    [_types.TEST_RUN_ERRORS.actionAdditionalSelectorMatchesWrongNodeTypeError]: err => markup(err, `
        The specified "${err.argumentName}" is expected to match a DOM element, but it matches a ${err.nodeDescription} node.
    `),

    [_types.TEST_RUN_ERRORS.actionElementNonEditableError]: err => markup(err, `
        The action element is expected to be editable (an input, textarea or element with the contentEditable attribute).
    `),

    [_types.TEST_RUN_ERRORS.actionElementNonContentEditableError]: err => markup(err, `
        The element that matches the specified "${err.argumentName}" is expected to have the contentEditable attribute enabled or the entire document should be in design mode.
    `),

    [_types.TEST_RUN_ERRORS.actionRootContainerNotFoundError]: err => markup(err, `
        Content between the action elements cannot be selected because the root container for the selection range cannot be found, i.e. these elements do not have a common ancestor with the contentEditable attribute.
    `),

    [_types.TEST_RUN_ERRORS.actionElementIsNotFileInputError]: err => markup(err, `
        The specified selector does not match a file input element.
    `),

    [_types.TEST_RUN_ERRORS.actionCannotFindFileToUploadError]: err => markup(err, `
        Cannot find the following file(s) to upload:
        ${err.filePaths.map(path => `  ${(0, _lodash.escape)(path)}`).join('\n')}
    `),

    [_types.TEST_RUN_ERRORS.actionElementNotTextAreaError]: err => markup(err, `
        The action element is expected to be a &lt;textarea&gt;.
    `),

    [_types.TEST_RUN_ERRORS.actionElementNotIframeError]: err => markup(err, `
        The action element is expected to be an &lt;iframe&gt.
    `),

    [_types.TEST_RUN_ERRORS.actionIncorrectKeysError]: err => markup(err, `
        The "${err.argumentName}" argument contains an incorrect key or key combination.
    `),

    [_types.TEST_RUN_ERRORS.actionUnsupportedDeviceTypeError]: err => markup(err, `
        The "${err.argumentName}" argument specifies an unsupported "${err.actualValue}" device. For a list of supported devices, refer to ${formatUrl(EXTERNAL_LINKS.viewportSizes)}.
    `),

    [_types.TEST_RUN_ERRORS.actionInvalidScrollTargetError]: err => markup(err, `
        Unable to scroll to the specified point because a point with the specified ${err.properties} is not located inside the element's cropping region.
    `),

    [_types.TEST_RUN_ERRORS.actionIframeIsNotLoadedError]: err => markup(err, `
        Content of the iframe to which you are switching did not load.
    `),

    [_types.TEST_RUN_ERRORS.currentIframeIsNotLoadedError]: err => markup(err, `
        Content of the iframe in which the test is currently operating did not load.
    `),

    [_types.TEST_RUN_ERRORS.currentIframeNotFoundError]: err => markup(err, `
        The iframe in which the test is currently operating does not exist anymore.
    `),

    [_types.TEST_RUN_ERRORS.currentIframeIsInvisibleError]: err => markup(err, `
        The iframe in which the test is currently operating is not visible anymore.
    `),

    [_types.TEST_RUN_ERRORS.missingAwaitError]: err => markup(err, `
        A call to an async function is not awaited. Use the "await" keyword before actions, assertions or chains of them to ensure that they run in the right sequence.
    `),

    [_types.TEST_RUN_ERRORS.externalAssertionLibraryError]: err => markup(err, `
        ${(0, _lodash.escape)(err.errMsg)}
    `),

    [_types.TEST_RUN_ERRORS.domNodeClientFunctionResultError]: err => markup(err, `
       ${err.instantiationCallsiteName} cannot return DOM elements. Use Selector functions for this purpose.
    `),

    [_types.TEST_RUN_ERRORS.invalidSelectorResultError]: err => markup(err, `
        Function that specifies a selector can only return a DOM node, an array of nodes, NodeList, HTMLCollection, null or undefined. Use ClientFunction to return other values.
    `),

    [_types.TEST_RUN_ERRORS.actionSelectorError]: err => markup(err, `
        Action "${err.selectorName}" argument error:

        ${(0, _lodash.escape)(err.errMsg)}
    `),

    [_types.TEST_RUN_ERRORS.cannotObtainInfoForElementSpecifiedBySelectorError]: (err, viewportWidth) => markup(err, `
        Cannot obtain information about the node because the specified selector does not match any node in the DOM tree.

        ${formatSelectorCallstack(err.apiFnChain, err.apiFnIndex, viewportWidth)}
    `),

    [_types.TEST_RUN_ERRORS.windowDimensionsOverflowError]: err => markup(err, `
        Unable to resize the window because the specified size exceeds the screen size. On macOS, a window cannot be larger than the screen.
    `),

    [_types.TEST_RUN_ERRORS.forbiddenCharactersInScreenshotPathError]: err => markup(err, `
        There are forbidden characters in the "${err.screenshotPath}" screenshot path:
        ${(0, _renderForbiddenCharsList2.default)(err.forbiddenCharsList)}
    `),

    [_types.TEST_RUN_ERRORS.invalidElementScreenshotDimensionsError]: err => markup(err, `
         Unable to capture an element image because the resulting image ${err.dimensions} ${err.verb} zero or negative.
    `),

    [_types.TEST_RUN_ERRORS.roleSwitchInRoleInitializerError]: err => markup(err, `
        Role cannot be switched while another role is being initialized.
    `),

    [_types.TEST_RUN_ERRORS.assertionExecutableArgumentError]: err => markup(err, `
        Cannot evaluate the "${err.actualValue}" expression in the "${err.argumentName}" parameter because of the following error:

        ${err.errMsg}
    `),

    [_types.TEST_RUN_ERRORS.assertionWithoutMethodCallError]: err => markup(err, `
        An assertion method is not specified.
    `),

    [_types.TEST_RUN_ERRORS.assertionUnawaitedPromiseError]: err => markup(err, `
        Attempted to run assertions on a Promise object. Did you forget to await it? If not, pass "{ allowUnawaitedPromise: true }" to the assertion options.
    `)
};
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9lcnJvcnMvdGVzdC1ydW4vdGVtcGxhdGVzLmpzIl0sIm5hbWVzIjpbIlNVQlRJVExFUyIsIlRFU1RfUlVOX1BIQVNFIiwiaW5pdGlhbCIsImluRml4dHVyZUJlZm9yZUhvb2siLCJpbkZpeHR1cmVCZWZvcmVFYWNoSG9vayIsImluVGVzdEJlZm9yZUhvb2siLCJpblRlc3QiLCJpblRlc3RBZnRlckhvb2siLCJpbkZpeHR1cmVBZnRlckVhY2hIb29rIiwiaW5GaXh0dXJlQWZ0ZXJIb29rIiwiaW5Sb2xlSW5pdGlhbGl6ZXIiLCJpbkJvb2ttYXJrUmVzdG9yZSIsIkVYVEVSTkFMX0xJTktTIiwiY3JlYXRlTmV3SXNzdWUiLCJ2aWV3cG9ydFNpemVzIiwiZm9ybWF0VXJsIiwidXJsIiwiZm9ybWF0U2VsZWN0b3JDYWxsc3RhY2siLCJhcGlGbkNoYWluIiwiYXBpRm5JbmRleCIsInZpZXdwb3J0V2lkdGgiLCJlbXB0eVNwYWNlcyIsImVsbGlwc2lzIiwiYXZhaWxhYmxlV2lkdGgiLCJtYXAiLCJhcGlGbiIsImluZGV4IiwiZm9ybWF0dGVkQXBpRm4iLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJsZW5ndGgiLCJzdWJzdHIiLCJqb2luIiwibWFya3VwIiwiZXJyIiwibXNnTWFya3VwIiwib3B0cyIsInRlc3RSdW5QaGFzZSIsInVzZXJBZ2VudCIsInNjcmVlbnNob3RQYXRoIiwid2l0aG91dENhbGxzaXRlIiwiY2FsbHNpdGVNYXJrdXAiLCJnZXRDYWxsc2l0ZU1hcmt1cCIsInJlcGxhY2UiLCJyZXBlYXQiLCJURVNUX1JVTl9FUlJPUlMiLCJhY3Rpb25JbnRlZ2VyT3B0aW9uRXJyb3IiLCJvcHRpb25OYW1lIiwiYWN0dWFsVmFsdWUiLCJhY3Rpb25Qb3NpdGl2ZUludGVnZXJPcHRpb25FcnJvciIsImFjdGlvbkJvb2xlYW5PcHRpb25FcnJvciIsImFjdGlvblNwZWVkT3B0aW9uRXJyb3IiLCJwYWdlTG9hZEVycm9yIiwiZXJyTXNnIiwidW5jYXVnaHRFcnJvck9uUGFnZSIsInBhZ2VEZXN0VXJsIiwiZXJyU3RhY2siLCJ1bmNhdWdodEVycm9ySW5UZXN0Q29kZSIsIm5hdGl2ZURpYWxvZ05vdEhhbmRsZWRFcnJvciIsImRpYWxvZ1R5cGUiLCJwYWdlVXJsIiwidW5jYXVnaHRFcnJvckluTmF0aXZlRGlhbG9nSGFuZGxlciIsInNldFRlc3RTcGVlZEFyZ3VtZW50RXJyb3IiLCJzZXROYXRpdmVEaWFsb2dIYW5kbGVyQ29kZVdyb25nVHlwZUVycm9yIiwiYWN0dWFsVHlwZSIsInVuY2F1Z2h0RXJyb3JJbkNsaWVudEZ1bmN0aW9uQ29kZSIsImluc3RhbnRpYXRpb25DYWxsc2l0ZU5hbWUiLCJ1bmNhdWdodEVycm9ySW5DdXN0b21ET01Qcm9wZXJ0eUNvZGUiLCJwcm9wZXJ0eSIsImNsaWVudEZ1bmN0aW9uRXhlY3V0aW9uSW50ZXJydXB0aW9uRXJyb3IiLCJ1bmNhdWdodE5vbkVycm9yT2JqZWN0SW5UZXN0Q29kZSIsIm9ialR5cGUiLCJvYmpTdHIiLCJ1bmhhbmRsZWRQcm9taXNlUmVqZWN0aW9uIiwidW5jYXVnaHRFeGNlcHRpb24iLCJhY3Rpb25PcHRpb25zVHlwZUVycm9yIiwiYWN0aW9uU3RyaW5nQXJndW1lbnRFcnJvciIsImFyZ3VtZW50TmFtZSIsImFjdGlvbkJvb2xlYW5Bcmd1bWVudEVycm9yIiwiYWN0aW9uTnVsbGFibGVTdHJpbmdBcmd1bWVudEVycm9yIiwiYWN0aW9uU3RyaW5nT3JTdHJpbmdBcnJheUFyZ3VtZW50RXJyb3IiLCJhY3Rpb25TdHJpbmdBcnJheUVsZW1lbnRFcnJvciIsImVsZW1lbnRJbmRleCIsImFjdGlvbkludGVnZXJBcmd1bWVudEVycm9yIiwiYWN0aW9uUm9sZUFyZ3VtZW50RXJyb3IiLCJhY3Rpb25Qb3NpdGl2ZUludGVnZXJBcmd1bWVudEVycm9yIiwiYWN0aW9uRWxlbWVudE5vdEZvdW5kRXJyb3IiLCJhY3Rpb25FbGVtZW50SXNJbnZpc2libGVFcnJvciIsImFjdGlvblNlbGVjdG9yTWF0Y2hlc1dyb25nTm9kZVR5cGVFcnJvciIsIm5vZGVEZXNjcmlwdGlvbiIsImFjdGlvbkFkZGl0aW9uYWxFbGVtZW50Tm90Rm91bmRFcnJvciIsImFjdGlvbkFkZGl0aW9uYWxFbGVtZW50SXNJbnZpc2libGVFcnJvciIsImFjdGlvbkFkZGl0aW9uYWxTZWxlY3Rvck1hdGNoZXNXcm9uZ05vZGVUeXBlRXJyb3IiLCJhY3Rpb25FbGVtZW50Tm9uRWRpdGFibGVFcnJvciIsImFjdGlvbkVsZW1lbnROb25Db250ZW50RWRpdGFibGVFcnJvciIsImFjdGlvblJvb3RDb250YWluZXJOb3RGb3VuZEVycm9yIiwiYWN0aW9uRWxlbWVudElzTm90RmlsZUlucHV0RXJyb3IiLCJhY3Rpb25DYW5ub3RGaW5kRmlsZVRvVXBsb2FkRXJyb3IiLCJmaWxlUGF0aHMiLCJwYXRoIiwiYWN0aW9uRWxlbWVudE5vdFRleHRBcmVhRXJyb3IiLCJhY3Rpb25FbGVtZW50Tm90SWZyYW1lRXJyb3IiLCJhY3Rpb25JbmNvcnJlY3RLZXlzRXJyb3IiLCJhY3Rpb25VbnN1cHBvcnRlZERldmljZVR5cGVFcnJvciIsImFjdGlvbkludmFsaWRTY3JvbGxUYXJnZXRFcnJvciIsInByb3BlcnRpZXMiLCJhY3Rpb25JZnJhbWVJc05vdExvYWRlZEVycm9yIiwiY3VycmVudElmcmFtZUlzTm90TG9hZGVkRXJyb3IiLCJjdXJyZW50SWZyYW1lTm90Rm91bmRFcnJvciIsImN1cnJlbnRJZnJhbWVJc0ludmlzaWJsZUVycm9yIiwibWlzc2luZ0F3YWl0RXJyb3IiLCJleHRlcm5hbEFzc2VydGlvbkxpYnJhcnlFcnJvciIsImRvbU5vZGVDbGllbnRGdW5jdGlvblJlc3VsdEVycm9yIiwiaW52YWxpZFNlbGVjdG9yUmVzdWx0RXJyb3IiLCJhY3Rpb25TZWxlY3RvckVycm9yIiwic2VsZWN0b3JOYW1lIiwiY2Fubm90T2J0YWluSW5mb0ZvckVsZW1lbnRTcGVjaWZpZWRCeVNlbGVjdG9yRXJyb3IiLCJ3aW5kb3dEaW1lbnNpb25zT3ZlcmZsb3dFcnJvciIsImZvcmJpZGRlbkNoYXJhY3RlcnNJblNjcmVlbnNob3RQYXRoRXJyb3IiLCJmb3JiaWRkZW5DaGFyc0xpc3QiLCJpbnZhbGlkRWxlbWVudFNjcmVlbnNob3REaW1lbnNpb25zRXJyb3IiLCJkaW1lbnNpb25zIiwidmVyYiIsInJvbGVTd2l0Y2hJblJvbGVJbml0aWFsaXplckVycm9yIiwiYXNzZXJ0aW9uRXhlY3V0YWJsZUFyZ3VtZW50RXJyb3IiLCJhc3NlcnRpb25XaXRob3V0TWV0aG9kQ2FsbEVycm9yIiwiYXNzZXJ0aW9uVW5hd2FpdGVkUHJvbWlzZUVycm9yIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQUNBOztBQUNBOzs7Ozs7QUFFQSxNQUFNQSxZQUFZO0FBQ2QsS0FBQ0MsZ0JBQWVDLE9BQWhCLEdBQTBDLEVBRDVCO0FBRWQsS0FBQ0QsZ0JBQWVFLG1CQUFoQixHQUEwQyw4REFGNUI7QUFHZCxLQUFDRixnQkFBZUcsdUJBQWhCLEdBQTBDLGtFQUg1QjtBQUlkLEtBQUNILGdCQUFlSSxnQkFBaEIsR0FBMEMsMkRBSjVCO0FBS2QsS0FBQ0osZ0JBQWVLLE1BQWhCLEdBQTBDLEVBTDVCO0FBTWQsS0FBQ0wsZ0JBQWVNLGVBQWhCLEdBQTBDLDBEQU41QjtBQU9kLEtBQUNOLGdCQUFlTyxzQkFBaEIsR0FBMEMsaUVBUDVCO0FBUWQsS0FBQ1AsZ0JBQWVRLGtCQUFoQixHQUEwQyw2REFSNUI7QUFTZCxLQUFDUixnQkFBZVMsaUJBQWhCLEdBQTBDLDJEQVQ1QjtBQVVkLEtBQUNULGdCQUFlVSxpQkFBaEIsR0FBMEM7QUFWNUIsQ0FBbEI7O0FBYUEsTUFBTUMsaUJBQWlCO0FBQ25CQyxvQkFBZ0IsMEVBREc7QUFFbkJDLG1CQUFnQjtBQUZHLENBQXZCOztBQUtBLFNBQVNDLFNBQVQsQ0FBb0JDLEdBQXBCLEVBQXlCO0FBQ3JCLFdBQVEsWUFBV0EsR0FBSSxLQUFJQSxHQUFJLE1BQS9CO0FBQ0g7O0FBRUQsU0FBU0MsdUJBQVQsQ0FBa0NDLFVBQWxDLEVBQThD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RSxnQ0FBakIsR0FBb0QxRixPQUFPRCxPQUFPQyxHQUFQLEVBQWE7K0JBQzdDQSxJQUFJYyxXQUFZLHdCQUF1QmQsSUFBSTJDLFlBQWE7O1VBRTdFM0MsSUFBSW1CLE1BQU87S0FIMEMsQ0FoUWhEOztBQXNRWCxLQUFDUix1QkFBZ0JnRiwrQkFBakIsR0FBbUQzRixPQUFPRCxPQUFPQyxHQUFQLEVBQWE7O0tBQWIsQ0F0US9DOztBQTBRWCxLQUFDVyx1QkFBZ0JpRiw4QkFBakIsR0FBa0Q1RixPQUFPRCxPQUFPQyxHQUFQLEVBQWE7O0tBQWI7QUExUTlDLEMiLCJmaWxlIjoiZXJyb3JzL3Rlc3QtcnVuL3RlbXBsYXRlcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBkZWRlbnQgZnJvbSAnZGVkZW50JztcbmltcG9ydCB7IGVzY2FwZSBhcyBlc2NhcGVIdG1sIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IFRFU1RfUlVOX0VSUk9SUyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCByZW5kZXJGb3JiaWRkZW5DaGFyc0xpc3QgZnJvbSAnLi4vcmVuZGVyLWZvcmJpZGRlbi1jaGFycy1saXN0JztcbmltcG9ydCB7IHJlcGxhY2VMZWFkaW5nU3BhY2VzV2l0aE5ic3AgfSBmcm9tICcuLi8uLi91dGlscy9zdHJpbmcnO1xuaW1wb3J0IFRFU1RfUlVOX1BIQVNFIGZyb20gJy4uLy4uL3Rlc3QtcnVuL3BoYXNlJztcblxuY29uc3QgU1VCVElUTEVTID0ge1xuICAgIFtURVNUX1JVTl9QSEFTRS5pbml0aWFsXTogICAgICAgICAgICAgICAgICcnLFxuICAgIFtURVNUX1JVTl9QSEFTRS5pbkZpeHR1cmVCZWZvcmVIb29rXTogICAgICc8c3BhbiBjbGFzcz1cInN1YnRpdGxlXCI+RXJyb3IgaW4gZml4dHVyZS5iZWZvcmUgaG9vazwvc3Bhbj5cXG4nLFxuICAgIFtURVNUX1JVTl9QSEFTRS5pbkZpeHR1cmVCZWZvcmVFYWNoSG9va106ICc8c3BhbiBjbGFzcz1cInN1YnRpdGxlXCI+RXJyb3IgaW4gZml4dHVyZS5iZWZvcmVFYWNoIGhvb2s8L3NwYW4+XFxuJyxcbiAgICBbVEVTVF9SVU5fUEhBU0UuaW5UZXN0QmVmb3JlSG9va106ICAgICAgICAnPHNwYW4gY2xhc3M9XCJzdWJ0aXRsZVwiPkVycm9yIGluIHRlc3QuYmVmb3JlIGhvb2s8L3NwYW4+XFxuJyxcbiAgICBbVEVTVF9SVU5fUEhBU0UuaW5UZXN0XTogICAgICAgICAgICAgICAgICAnJyxcbiAgICBbVEVTVF9SVU5fUEhBU0UuaW5UZXN0QWZ0ZXJIb29rXTogICAgICAgICAnPHNwYW4gY2xhc3M9XCJzdWJ0aXRsZVwiPkVycm9yIGluIHRlc3QuYWZ0ZXIgaG9vazwvc3Bhbj5cXG4nLFxuICAgIFtURVNUX1JVTl9QSEFTRS5pbkZpeHR1cmVBZnRlckVhY2hIb29rXTogICc8c3BhbiBjbGFzcz1cInN1YnRpdGxlXCI+RXJyb3IgaW4gZml4dHVyZS5hZnRlckVhY2ggaG9vazwvc3Bhbj5cXG4nLFxuICAgIFtURVNUX1JVTl9QSEFTRS5pbkZpeHR1cmVBZnRlckhvb2tdOiAgICAgICc8c3BhbiBjbGFzcz1cInN1YnRpdGxlXCI+RXJyb3IgaW4gZml4dHVyZS5hZnRlciBob29rPC9zcGFuPlxcbicsXG4gICAgW1RFU1RfUlVOX1BIQVNFLmluUm9sZUluaXRpYWxpemVyXTogICAgICAgJzxzcGFuIGNsYXNzPVwic3VidGl0bGVcIj5FcnJvciBpbiBSb2xlIGluaXRpYWxpemVyPC9zcGFuPlxcbicsXG4gICAgW1RFU1RfUlVOX1BIQVNFLmluQm9va21hcmtSZXN0b3JlXTogICAgICAgJzxzcGFuIGNsYXNzPVwic3VidGl0bGVcIj5FcnJvciB3aGlsZSByZXN0b3JpbmcgY29uZmlndXJhdGlvbiBhZnRlciBSb2xlIHN3aXRjaDwvc3Bhbj5cXG4nXG59O1xuXG5jb25zdCBFWFRFUk5BTF9MSU5LUyA9IHtcbiAgICBjcmVhdGVOZXdJc3N1ZTogJ2h0dHBzOi8vZ2l0aHViLmNvbS9EZXZFeHByZXNzL3Rlc3RjYWZlL2lzc3Vlcy9uZXc/dGVtcGxhdGU9YnVnLXJlcG9ydC5tZCcsXG4gICAgdmlld3BvcnRTaXplczogICdodHRwOi8vdmlld3BvcnRzaXplcy5jb20nXG59O1xuXG5mdW5jdGlvbiBmb3JtYXRVcmwgKHVybCkge1xuICAgIHJldHVybiBgPGEgaHJlZj1cIiR7dXJsfVwiPiR7dXJsfTwvYT5gO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRTZWxlY3RvckNhbGxzdGFjayAoYXBpRm5DaGFpbiwgYXBpRm5JbmRleCwgdmlld3BvcnRXaWR0aCkge1xuICAgIGlmICh0eXBlb2YgYXBpRm5JbmRleCA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJldHVybiAnJztcblxuICAgIGNvbnN0IGVtcHR5U3BhY2VzICAgID0gMTA7XG4gICAgY29uc3QgZWxsaXBzaXMgICAgICAgPSAnLi4uKSc7XG4gICAgY29uc3QgYXZhaWxhYmxlV2lkdGggPSB2aWV3cG9ydFdpZHRoIC0gZW1wdHlTcGFjZXM7XG5cbiAgICByZXR1cm4gYXBpRm5DaGFpbi5tYXAoKGFwaUZuLCBpbmRleCkgPT4ge1xuICAgICAgICBsZXQgZm9ybWF0dGVkQXBpRm4gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDE2MCk7XG5cbiAgICAgICAgZm9ybWF0dGVkQXBpRm4gKz0gaW5kZXggPT09IGFwaUZuSW5kZXggPyAnPicgOiAnICc7XG4gICAgICAgIGZvcm1hdHRlZEFwaUZuICs9ICcgfCAnO1xuICAgICAgICBmb3JtYXR0ZWRBcGlGbiArPSBpbmRleCAhPT0gMCA/ICcgICcgOiAnJztcbiAgICAgICAgZm9ybWF0dGVkQXBpRm4gKz0gYXBpRm47XG5cbiAgICAgICAgaWYgKGZvcm1hdHRlZEFwaUZuLmxlbmd0aCA+IGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdHRlZEFwaUZuLnN1YnN0cigwLCBhdmFpbGFibGVXaWR0aCAtIGVtcHR5U3BhY2VzKSArIGVsbGlwc2lzO1xuXG4gICAgICAgIHJldHVybiBmb3JtYXR0ZWRBcGlGbjtcbiAgICB9KS5qb2luKCdcXG4nKTtcbn1cblxuZnVuY3Rpb24gbWFya3VwIChlcnIsIG1zZ01hcmt1cCwgb3B0cyA9IHt9KSB7XG4gICAgbXNnTWFya3VwID0gZGVkZW50KGBcbiAgICAgICAgJHtTVUJUSVRMRVNbZXJyLnRlc3RSdW5QaGFzZV19PGRpdiBjbGFzcz1cIm1lc3NhZ2VcIj4ke2RlZGVudChtc2dNYXJrdXApfTwvZGl2PlxuXG4gICAgICAgIDxzdHJvbmc+QnJvd3Nlcjo8L3N0cm9uZz4gPHNwYW4gY2xhc3M9XCJ1c2VyLWFnZW50XCI+JHtlcnIudXNlckFnZW50fTwvc3Bhbj5cbiAgICBgKTtcblxuICAgIGlmIChlcnIuc2NyZWVuc2hvdFBhdGgpXG4gICAgICAgIG1zZ01hcmt1cCArPSBgXFxuPGRpdiBjbGFzcz1cInNjcmVlbnNob3QtaW5mb1wiPjxzdHJvbmc+U2NyZWVuc2hvdDo8L3N0cm9uZz4gPGEgY2xhc3M9XCJzY3JlZW5zaG90LXBhdGhcIj4ke2VzY2FwZUh0bWwoZXJyLnNjcmVlbnNob3RQYXRoKX08L2E+PC9kaXY+YDtcblxuICAgIGlmICghb3B0cy53aXRob3V0Q2FsbHNpdGUpIHtcbiAgICAgICAgY29uc3QgY2FsbHNpdGVNYXJrdXAgPSBlcnIuZ2V0Q2FsbHNpdGVNYXJrdXAoKTtcblxuICAgICAgICBpZiAoY2FsbHNpdGVNYXJrdXApXG4gICAgICAgICAgICBtc2dNYXJrdXAgKz0gYFxcblxcbiR7Y2FsbHNpdGVNYXJrdXB9YDtcbiAgICB9XG5cbiAgICByZXR1cm4gbXNnTWFya3VwXG4gICAgICAgIC5yZXBsYWNlKCdcXHQnLCAnJm5ic3A7Jy5yZXBlYXQoNCkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgW1RFU1RfUlVOX0VSUk9SUy5hY3Rpb25JbnRlZ2VyT3B0aW9uRXJyb3JdOiBlcnIgPT4gbWFya3VwKGVyciwgYFxuICAgICAgICBUaGUgXCIke2Vyci5vcHRpb25OYW1lfVwiIG9wdGlvbiBpcyBleHBlY3RlZCB0byBiZSBhbiBpbnRlZ2VyLCBidXQgaXQgd2FzICR7ZXJyLmFjdHVhbFZhbHVlfS5cbiAgICBgKSxcblxuICAgIFtURVNUX1JVTl9FUlJPUlMuYWN0aW9uUG9zaXRpdmVJbnRlZ2VyT3B0aW9uRXJyb3JdOiBlcnIgPT4gbWFya3VwKGVyciwgYFxuICAgICAgICBUaGUgXCIke2Vyci5vcHRpb25OYW1lfVwiIG9wdGlvbiBpcyBleHBlY3RlZCB0byBiZSBhIHBvc2l0aXZlIGludGVnZXIsIGJ1dCBpdCB3YXMgJHtlcnIuYWN0dWFsVmFsdWV9LlxuICAgIGApLFxuXG4gICAgW1RFU1RfUlVOX0VSUk9SUy5hY3Rpb25Cb29sZWFuT3B0aW9uRXJyb3JdOiBlcnIgPT4gbWFya3VwKGVyciwgYFxuICAgICAgICBUaGUgXCIke2Vyci5vcHRpb25OYW1lfVwiIG9wdGlvbiBpcyBleHBlY3RlZCB0byBiZSBhIGJvb2xlYW4gdmFsdWUsIGJ1dCBpdCB3YXMgJHtlcnIuYWN0dWFsVmFsdWV9LlxuICAgIGApLFxuXG4gICAgW1RFU1RfUlVOX0VSUk9SUy5hY3Rpb25TcGVlZE9wdGlvbkVycm9yXTogZXJyID0+IG1hcmt1cChlcnIsIGBcbiAgICAgICAgVGhlIFwiJHtlcnIub3B0aW9uTmFtZX1cIiBvcHRpb24gaXMgZXhwZWN0ZWQgdG8gYmUgYSBudW1iZXIgYmV0d2VlbiAwLjAxIGFuZCAxLCBidXQgaXQgd2FzICR7ZXJyLmFjdHVhbFZhbHVlfS5cbiAgICBgKSxcblxuICAgIFtURVNUX1JVTl9FUlJPUlMucGFnZUxvYWRFcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgICR7ZXJyLmVyck1zZ31cbiAgICBgKSxcblxuICAgIFtURVNUX1JVTl9FUlJPUlMudW5jYXVnaHRFcnJvck9uUGFnZV06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIEEgSmF2YVNjcmlwdCBlcnJvciBvY2N1cnJlZCBvbiAke2Zvcm1hdFVybChlcnIucGFnZURlc3RVcmwpfS5cbiAgICAgICAgQXQgdGhpcyBtb21lbnQsIFRlc3RDYWZlIHRyYWNrcyB1bmNhdWdodCBKYXZhU2NyaXB0IGVycm9ycyBvbiB0aGUgcGFnZS4gVHJ5IHRvIG1hbnVhbGx5IHBlcmZvcm0gdGhlIHRlc3Qgc2NlbmFyaW8uXG4gICAgICAgIElmIHRoaXMgZXJyb3Igc3RpbGwgb2NjdXJzIHRoZW4gaXQgbWVhbnMgeW91IHNpdGUgaGFzIHVuY2F1Z2h0IEphdmFTY3JpcHQgZXJyb3JzLiBUbyBkaXNhYmxlIEphdmFTY3JpcHQgZXJyb3IgdHJhY2tpbmcgeW91IGNhbiB0dXJuIHRoZSAtLXNraXAtanMtZXJyb3JzIG9wdGlvbiBvbi5cbiAgICAgICAgSWYgdGhlIGVycm9yIG9jY3VycyBvbmx5IHdpdGggVGVzdENhZmUgdGhlbiBpdCBpcyBhIGJ1Zy4gV3JpdGUgYSBuZXcgaXNzdWUgYWJvdXQgaXQgYXQ6XG4gICAgICAgICR7Zm9ybWF0VXJsKEVYVEVSTkFMX0xJTktTLmNyZWF0ZU5ld0lzc3VlKX0uXG5cbiAgICAgICAgSmF2YVNjcmlwdCBlcnJvciBkZXRhaWxzOlxuICAgICAgICAke3JlcGxhY2VMZWFkaW5nU3BhY2VzV2l0aE5ic3AoZXNjYXBlSHRtbChlcnIuZXJyU3RhY2spKX1cbiAgICBgKSxcblxuICAgIFtURVNUX1JVTl9FUlJPUlMudW5jYXVnaHRFcnJvckluVGVzdENvZGVdOiBlcnIgPT4gbWFya3VwKGVyciwgYFxuICAgICAgICAke2VzY2FwZUh0bWwoZXJyLmVyck1zZyl9XG4gICAgYCksXG5cbiAgICBbVEVTVF9SVU5fRVJST1JTLm5hdGl2ZURpYWxvZ05vdEhhbmRsZWRFcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIEEgbmF0aXZlICR7ZXJyLmRpYWxvZ1R5cGV9IGRpYWxvZyB3YXMgaW52b2tlZCBvbiBwYWdlICR7Zm9ybWF0VXJsKGVyci5wYWdlVXJsKX0sIGJ1dCBubyBoYW5kbGVyIHdhcyBzZXQgZm9yIGl0LiBVc2UgdGhlIFwic2V0TmF0aXZlRGlhbG9nSGFuZGxlclwiIGZ1bmN0aW9uIHRvIGludHJvZHVjZSBhIGhhbmRsZXIgZnVuY3Rpb24gZm9yIG5hdGl2ZSBkaWFsb2dzLlxuICAgIGApLFxuXG4gICAgW1RFU1RfUlVOX0VSUk9SUy5uYXRpdmVEaWFsb2dOb3RIYW5kbGVkRXJyb3JdOiBlcnIgPT4gbWFya3VwKGVyciwgYFxuICAgICAgICBBIG5hdGl2ZSAke2Vyci5kaWFsb2dUeXBlfSBkaWFsb2cgd2FzIGludm9rZWQgb24gcGFnZSA8YSBocmVmPVwiJHtlcnIucGFnZVVybH1cIj4ke2Vyci5wYWdlVXJsfTwvYT4sIGJ1dCBubyBoYW5kbGVyIHdhcyBzZXQgZm9yIGl0LiBVc2UgdGhlIFwic2V0TmF0aXZlRGlhbG9nSGFuZGxlclwiIGZ1bmN0aW9uIHRvIGludHJvZHVjZSBhIGhhbmRsZXIgZnVuY3Rpb24gZm9yIG5hdGl2ZSBkaWFsb2dzLlxuICAgIGApLFxuXG4gICAgW1RFU1RfUlVOX0VSUk9SUy51bmNhdWdodEVycm9ySW5OYXRpdmVEaWFsb2dIYW5kbGVyXTogZXJyID0+IG1hcmt1cChlcnIsIGBcbiAgICAgICAgQW4gZXJyb3Igb2NjdXJyZWQgaW4gdGhlIG5hdGl2ZSBkaWFsb2cgaGFuZGxlciBjYWxsZWQgZm9yIGEgbmF0aXZlICR7ZXJyLmRpYWxvZ1R5cGV9IGRpYWxvZyBvbiBwYWdlIDxhIGhyZWY9XCIke2Vyci5wYWdlVXJsfVwiPiR7ZXJyLnBhZ2VVcmx9PC9hPjpcblxuICAgICAgICAke2VzY2FwZUh0bWwoZXJyLmVyck1zZyl9XG4gICAgYCksXG5cbiAgICBbVEVTVF9SVU5fRVJST1JTLnNldFRlc3RTcGVlZEFyZ3VtZW50RXJyb3JdOiBlcnIgPT4gbWFya3VwKGVyciwgYFxuICAgICAgICBTcGVlZCBpcyBleHBlY3RlZCB0byBiZSBhIG51bWJlciBiZXR3ZWVuIDAuMDEgYW5kIDEsIGJ1dCAke2Vyci5hY3R1YWxWYWx1ZX0gd2FzIHBhc3NlZC5cbiAgICBgKSxcblxuICAgIFtURVNUX1JVTl9FUlJPUlMuc2V0TmF0aXZlRGlhbG9nSGFuZGxlckNvZGVXcm9uZ1R5cGVFcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIFRoZSBuYXRpdmUgZGlhbG9nIGhhbmRsZXIgaXMgZXhwZWN0ZWQgdG8gYmUgYSBmdW5jdGlvbiwgQ2xpZW50RnVuY3Rpb24gb3IgbnVsbCwgYnV0IGl0IHdhcyAke2Vyci5hY3R1YWxUeXBlfS5cbiAgICBgKSxcblxuICAgIFtURVNUX1JVTl9FUlJPUlMudW5jYXVnaHRFcnJvckluQ2xpZW50RnVuY3Rpb25Db2RlXTogZXJyID0+IG1hcmt1cChlcnIsIGBcbiAgICAgICAgQW4gZXJyb3Igb2NjdXJyZWQgaW4gJHtlcnIuaW5zdGFudGlhdGlvbkNhbGxzaXRlTmFtZX0gY29kZTpcblxuICAgICAgICAke2VzY2FwZUh0bWwoZXJyLmVyck1zZyl9XG4gICAgYCksXG5cbiAgICBbVEVTVF9SVU5fRVJST1JTLnVuY2F1Z2h0RXJyb3JJbkN1c3RvbURPTVByb3BlcnR5Q29kZV06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIEFuIGVycm9yIG9jY3VycmVkIHdoZW4gdHJ5aW5nIHRvIGNhbGN1bGF0ZSBhIGN1c3RvbSBTZWxlY3RvciBwcm9wZXJ0eSBcIiR7ZXJyLnByb3BlcnR5fVwiOlxuXG4gICAgICAgICR7ZXNjYXBlSHRtbChlcnIuZXJyTXNnKX1cbiAgICBgKSxcblxuICAgIFtURVNUX1JVTl9FUlJPUlMuY2xpZW50RnVuY3Rpb25FeGVjdXRpb25JbnRlcnJ1cHRpb25FcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgICR7ZXJyLmluc3RhbnRpYXRpb25DYWxsc2l0ZU5hbWV9IGV4ZWN1dGlvbiB3YXMgaW50ZXJydXB0ZWQgYnkgcGFnZSB1bmxvYWQuIFRoaXMgcHJvYmxlbSBtYXkgYXBwZWFyIGlmIHlvdSB0cmlnZ2VyIHBhZ2UgbmF2aWdhdGlvbiBmcm9tICR7ZXJyLmluc3RhbnRpYXRpb25DYWxsc2l0ZU5hbWV9IGNvZGUuXG4gICAgYCksXG5cbiAgICBbVEVTVF9SVU5fRVJST1JTLnVuY2F1Z2h0Tm9uRXJyb3JPYmplY3RJblRlc3RDb2RlXTogZXJyID0+IG1hcmt1cChlcnIsIGBcbiAgICAgICAgVW5jYXVnaHQgJHtlcnIub2JqVHlwZX0gXCIke2VzY2FwZUh0bWwoZXJyLm9ialN0cil9XCIgd2FzIHRocm93bi4gVGhyb3cgRXJyb3IgaW5zdGVhZC5cbiAgICBgLCB7IHdpdGhvdXRDYWxsc2l0ZTogdHJ1ZSB9KSxcblxuICAgIFtURVNUX1JVTl9FUlJPUlMudW5oYW5kbGVkUHJvbWlzZVJlamVjdGlvbl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIFVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbjpcblxuICAgICAgICAke2VzY2FwZUh0bWwoZXJyLmVyck1zZyl9XG4gICAgYCwgeyB3aXRob3V0Q2FsbHNpdGU6IHRydWUgfSksXG5cbiAgICBbVEVTVF9SVU5fRVJST1JTLnVuY2F1Z2h0RXhjZXB0aW9uXTogZXJyID0+IG1hcmt1cChlcnIsIGBcbiAgICAgICAgVW5jYXVnaHQgZXhjZXB0aW9uOlxuXG4gICAgICAgICR7ZXNjYXBlSHRtbChlcnIuZXJyTXNnKX1cbiAgICBgLCB7IHdpdGhvdXRDYWxsc2l0ZTogdHJ1ZSB9KSxcblxuICAgIFtURVNUX1JVTl9FUlJPUlMuYWN0aW9uT3B0aW9uc1R5cGVFcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIEFjdGlvbiBvcHRpb25zIGlzIGV4cGVjdGVkIHRvIGJlIGFuIG9iamVjdCwgbnVsbCBvciB1bmRlZmluZWQgYnV0IGl0IHdhcyAke2Vyci5hY3R1YWxUeXBlfS5cbiAgICBgKSxcblxuICAgIFtURVNUX1JVTl9FUlJPUlMuYWN0aW9uU3RyaW5nQXJndW1lbnRFcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIFRoZSBcIiR7ZXJyLmFyZ3VtZW50TmFtZX1cIiBhcmd1bWVudCBpcyBleHBlY3RlZCB0byBiZSBhIG5vbi1lbXB0eSBzdHJpbmcsIGJ1dCBpdCB3YXMgJHtlcnIuYWN0dWFsVmFsdWV9LlxuICAgIGApLFxuXG4gICAgW1RFU1RfUlVOX0VSUk9SUy5hY3Rpb25Cb29sZWFuQXJndW1lbnRFcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIFRoZSBcIiR7ZXJyLmFyZ3VtZW50TmFtZX1cIiBhcmd1bWVudCBpcyBleHBlY3RlZCB0byBiZSBhIGJvb2xlYW4gdmFsdWUsIGJ1dCBpdCB3YXMgJHtlcnIuYWN0dWFsVmFsdWV9LlxuICAgIGApLFxuXG4gICAgW1RFU1RfUlVOX0VSUk9SUy5hY3Rpb25OdWxsYWJsZVN0cmluZ0FyZ3VtZW50RXJyb3JdOiBlcnIgPT4gbWFya3VwKGVyciwgYFxuICAgICAgICBUaGUgXCIke2Vyci5hcmd1bWVudE5hbWV9XCIgYXJndW1lbnQgaXMgZXhwZWN0ZWQgdG8gYmUgYSBudWxsIG9yIGEgc3RyaW5nLCBidXQgaXQgd2FzICR7ZXJyLmFjdHVhbFZhbHVlfS5cbiAgICBgKSxcblxuICAgIFtURVNUX1JVTl9FUlJPUlMuYWN0aW9uU3RyaW5nT3JTdHJpbmdBcnJheUFyZ3VtZW50RXJyb3JdOiBlcnIgPT4gbWFya3VwKGVyciwgYFxuICAgICAgICBUaGUgXCIke2Vyci5hcmd1bWVudE5hbWV9XCIgYXJndW1lbnQgaXMgZXhwZWN0ZWQgdG8gYmUgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgc3RyaW5nIGFycmF5LCBidXQgaXQgd2FzICR7ZXJyLmFjdHVhbFZhbHVlfS5cbiAgICBgKSxcblxuICAgIFtURVNUX1JVTl9FUlJPUlMuYWN0aW9uU3RyaW5nQXJyYXlFbGVtZW50RXJyb3JdOiBlcnIgPT4gbWFya3VwKGVyciwgYFxuICAgICAgICBFbGVtZW50cyBvZiB0aGUgXCIke2Vyci5hcmd1bWVudE5hbWV9XCIgYXJndW1lbnQgYXJlIGV4cGVjdGVkIHRvIGJlIG5vbi1lbXB0eSBzdHJpbmdzLCBidXQgdGhlIGVsZW1lbnQgYXQgaW5kZXggJHtlcnIuZWxlbWVudEluZGV4fSB3YXMgJHtlcnIuYWN0dWFsVmFsdWV9LlxuICAgIGApLFxuXG4gICAgW1RFU1RfUlVOX0VSUk9SUy5hY3Rpb25JbnRlZ2VyQXJndW1lbnRFcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIFRoZSBcIiR7ZXJyLmFyZ3VtZW50TmFtZX1cIiBhcmd1bWVudCBpcyBleHBlY3RlZCB0byBiZSBhbiBpbnRlZ2VyLCBidXQgaXQgd2FzICR7ZXJyLmFjdHVhbFZhbHVlfS5cbiAgICBgKSxcblxuICAgIFtURVNUX1JVTl9FUlJPUlMuYWN0aW9uUm9sZUFyZ3VtZW50RXJyb3JdOiBlcnIgPT4gbWFya3VwKGVyciwgYFxuICAgICAgICBUaGUgXCIke2Vyci5hcmd1bWVudE5hbWV9XCIgYXJndW1lbnQgaXMgZXhwZWN0ZWQgdG8gYmUgYSBSb2xlIGluc3RhbmNlLCBidXQgaXQgd2FzICR7ZXJyLmFjdHVhbFZhbHVlfS5cbiAgICBgKSxcblxuICAgIFtURVNUX1JVTl9FUlJPUlMuYWN0aW9uUG9zaXRpdmVJbnRlZ2VyQXJndW1lbnRFcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIFRoZSBcIiR7ZXJyLmFyZ3VtZW50TmFtZX1cIiBhcmd1bWVudCBpcyBleHBlY3RlZCB0byBiZSBhIHBvc2l0aXZlIGludGVnZXIsIGJ1dCBpdCB3YXMgJHtlcnIuYWN0dWFsVmFsdWV9LlxuICAgIGApLFxuXG4gICAgW1RFU1RfUlVOX0VSUk9SUy5hY3Rpb25FbGVtZW50Tm90Rm91bmRFcnJvcl06IChlcnIsIHZpZXdwb3J0V2lkdGgpID0+IG1hcmt1cChlcnIsIGBcbiAgICAgICAgVGhlIHNwZWNpZmllZCBzZWxlY3RvciBkb2VzIG5vdCBtYXRjaCBhbnkgZWxlbWVudCBpbiB0aGUgRE9NIHRyZWUuXG5cbiAgICAgICAgJHsgZm9ybWF0U2VsZWN0b3JDYWxsc3RhY2soZXJyLmFwaUZuQ2hhaW4sIGVyci5hcGlGbkluZGV4LCB2aWV3cG9ydFdpZHRoKSB9XG4gICAgYCksXG5cbiAgICBbVEVTVF9SVU5fRVJST1JTLmFjdGlvbkVsZW1lbnRJc0ludmlzaWJsZUVycm9yXTogZXJyID0+IG1hcmt1cChlcnIsIGBcbiAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCBtYXRjaGVzIHRoZSBzcGVjaWZpZWQgc2VsZWN0b3IgaXMgbm90IHZpc2libGUuXG4gICAgYCksXG5cbiAgICBbVEVTVF9SVU5fRVJST1JTLmFjdGlvblNlbGVjdG9yTWF0Y2hlc1dyb25nTm9kZVR5cGVFcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIFRoZSBzcGVjaWZpZWQgc2VsZWN0b3IgaXMgZXhwZWN0ZWQgdG8gbWF0Y2ggYSBET00gZWxlbWVudCwgYnV0IGl0IG1hdGNoZXMgYSAke2Vyci5ub2RlRGVzY3JpcHRpb259IG5vZGUuXG4gICAgYCksXG5cbiAgICBbVEVTVF9SVU5fRVJST1JTLmFjdGlvbkFkZGl0aW9uYWxFbGVtZW50Tm90Rm91bmRFcnJvcl06IChlcnIsIHZpZXdwb3J0V2lkdGgpID0+IG1hcmt1cChlcnIsIGBcbiAgICAgICAgVGhlIHNwZWNpZmllZCBcIiR7ZXJyLmFyZ3VtZW50TmFtZX1cIiBkb2VzIG5vdCBtYXRjaCBhbnkgZWxlbWVudCBpbiB0aGUgRE9NIHRyZWUuXG5cbiAgICAgICAgJHsgZm9ybWF0U2VsZWN0b3JDYWxsc3RhY2soZXJyLmFwaUZuQ2hhaW4sIGVyci5hcGlGbkluZGV4LCB2aWV3cG9ydFdpZHRoKSB9XG4gICAgYCksXG5cbiAgICBbVEVTVF9SVU5fRVJST1JTLmFjdGlvbkFkZGl0aW9uYWxFbGVtZW50SXNJbnZpc2libGVFcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIFRoZSBlbGVtZW50IHRoYXQgbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIFwiJHtlcnIuYXJndW1lbnROYW1lfVwiIGlzIG5vdCB2aXNpYmxlLlxuICAgIGApLFxuXG4gICAgW1RFU1RfUlVOX0VSUk9SUy5hY3Rpb25BZGRpdGlvbmFsU2VsZWN0b3JNYXRjaGVzV3JvbmdOb2RlVHlwZUVycm9yXTogZXJyID0+IG1hcmt1cChlcnIsIGBcbiAgICAgICAgVGhlIHNwZWNpZmllZCBcIiR7ZXJyLmFyZ3VtZW50TmFtZX1cIiBpcyBleHBlY3RlZCB0byBtYXRjaCBhIERPTSBlbGVtZW50LCBidXQgaXQgbWF0Y2hlcyBhICR7ZXJyLm5vZGVEZXNjcmlwdGlvbn0gbm9kZS5cbiAgICBgKSxcblxuICAgIFtURVNUX1JVTl9FUlJPUlMuYWN0aW9uRWxlbWVudE5vbkVkaXRhYmxlRXJyb3JdOiBlcnIgPT4gbWFya3VwKGVyciwgYFxuICAgICAgICBUaGUgYWN0aW9uIGVsZW1lbnQgaXMgZXhwZWN0ZWQgdG8gYmUgZWRpdGFibGUgKGFuIGlucHV0LCB0ZXh0YXJlYSBvciBlbGVtZW50IHdpdGggdGhlIGNvbnRlbnRFZGl0YWJsZSBhdHRyaWJ1dGUpLlxuICAgIGApLFxuXG4gICAgW1RFU1RfUlVOX0VSUk9SUy5hY3Rpb25FbGVtZW50Tm9uQ29udGVudEVkaXRhYmxlRXJyb3JdOiBlcnIgPT4gbWFya3VwKGVyciwgYFxuICAgICAgICBUaGUgZWxlbWVudCB0aGF0IG1hdGNoZXMgdGhlIHNwZWNpZmllZCBcIiR7ZXJyLmFyZ3VtZW50TmFtZX1cIiBpcyBleHBlY3RlZCB0byBoYXZlIHRoZSBjb250ZW50RWRpdGFibGUgYXR0cmlidXRlIGVuYWJsZWQgb3IgdGhlIGVudGlyZSBkb2N1bWVudCBzaG91bGQgYmUgaW4gZGVzaWduIG1vZGUuXG4gICAgYCksXG5cbiAgICBbVEVTVF9SVU5fRVJST1JTLmFjdGlvblJvb3RDb250YWluZXJOb3RGb3VuZEVycm9yXTogZXJyID0+IG1hcmt1cChlcnIsIGBcbiAgICAgICAgQ29udGVudCBiZXR3ZWVuIHRoZSBhY3Rpb24gZWxlbWVudHMgY2Fubm90IGJlIHNlbGVjdGVkIGJlY2F1c2UgdGhlIHJvb3QgY29udGFpbmVyIGZvciB0aGUgc2VsZWN0aW9uIHJhbmdlIGNhbm5vdCBiZSBmb3VuZCwgaS5lLiB0aGVzZSBlbGVtZW50cyBkbyBub3QgaGF2ZSBhIGNvbW1vbiBhbmNlc3RvciB3aXRoIHRoZSBjb250ZW50RWRpdGFibGUgYXR0cmlidXRlLlxuICAgIGApLFxuXG4gICAgW1RFU1RfUlVOX0VSUk9SUy5hY3Rpb25FbGVtZW50SXNOb3RGaWxlSW5wdXRFcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIFRoZSBzcGVjaWZpZWQgc2VsZWN0b3IgZG9lcyBub3QgbWF0Y2ggYSBmaWxlIGlucHV0IGVsZW1lbnQuXG4gICAgYCksXG5cbiAgICBbVEVTVF9SVU5fRVJST1JTLmFjdGlvbkNhbm5vdEZpbmRGaWxlVG9VcGxvYWRFcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIENhbm5vdCBmaW5kIHRoZSBmb2xsb3dpbmcgZmlsZShzKSB0byB1cGxvYWQ6XG4gICAgICAgICR7ZXJyLmZpbGVQYXRocy5tYXAocGF0aCA9PiBgICAke2VzY2FwZUh0bWwocGF0aCl9YCkuam9pbignXFxuJyl9XG4gICAgYCksXG5cbiAgICBbVEVTVF9SVU5fRVJST1JTLmFjdGlvbkVsZW1lbnROb3RUZXh0QXJlYUVycm9yXTogZXJyID0+IG1hcmt1cChlcnIsIGBcbiAgICAgICAgVGhlIGFjdGlvbiBlbGVtZW50IGlzIGV4cGVjdGVkIHRvIGJlIGEgJmx0O3RleHRhcmVhJmd0Oy5cbiAgICBgKSxcblxuICAgIFtURVNUX1JVTl9FUlJPUlMuYWN0aW9uRWxlbWVudE5vdElmcmFtZUVycm9yXTogZXJyID0+IG1hcmt1cChlcnIsIGBcbiAgICAgICAgVGhlIGFjdGlvbiBlbGVtZW50IGlzIGV4cGVjdGVkIHRvIGJlIGFuICZsdDtpZnJhbWUmZ3QuXG4gICAgYCksXG5cbiAgICBbVEVTVF9SVU5fRVJST1JTLmFjdGlvbkluY29ycmVjdEtleXNFcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIFRoZSBcIiR7ZXJyLmFyZ3VtZW50TmFtZX1cIiBhcmd1bWVudCBjb250YWlucyBhbiBpbmNvcnJlY3Qga2V5IG9yIGtleSBjb21iaW5hdGlvbi5cbiAgICBgKSxcblxuICAgIFtURVNUX1JVTl9FUlJPUlMuYWN0aW9uVW5zdXBwb3J0ZWREZXZpY2VUeXBlRXJyb3JdOiBlcnIgPT4gbWFya3VwKGVyciwgYFxuICAgICAgICBUaGUgXCIke2Vyci5hcmd1bWVudE5hbWV9XCIgYXJndW1lbnQgc3BlY2lmaWVzIGFuIHVuc3VwcG9ydGVkIFwiJHtlcnIuYWN0dWFsVmFsdWV9XCIgZGV2aWNlLiBGb3IgYSBsaXN0IG9mIHN1cHBvcnRlZCBkZXZpY2VzLCByZWZlciB0byAke2Zvcm1hdFVybChFWFRFUk5BTF9MSU5LUy52aWV3cG9ydFNpemVzKX0uXG4gICAgYCksXG5cbiAgICBbVEVTVF9SVU5fRVJST1JTLmFjdGlvbkludmFsaWRTY3JvbGxUYXJnZXRFcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIFVuYWJsZSB0byBzY3JvbGwgdG8gdGhlIHNwZWNpZmllZCBwb2ludCBiZWNhdXNlIGEgcG9pbnQgd2l0aCB0aGUgc3BlY2lmaWVkICR7ZXJyLnByb3BlcnRpZXN9IGlzIG5vdCBsb2NhdGVkIGluc2lkZSB0aGUgZWxlbWVudCdzIGNyb3BwaW5nIHJlZ2lvbi5cbiAgICBgKSxcblxuICAgIFtURVNUX1JVTl9FUlJPUlMuYWN0aW9uSWZyYW1lSXNOb3RMb2FkZWRFcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIENvbnRlbnQgb2YgdGhlIGlmcmFtZSB0byB3aGljaCB5b3UgYXJlIHN3aXRjaGluZyBkaWQgbm90IGxvYWQuXG4gICAgYCksXG5cbiAgICBbVEVTVF9SVU5fRVJST1JTLmN1cnJlbnRJZnJhbWVJc05vdExvYWRlZEVycm9yXTogZXJyID0+IG1hcmt1cChlcnIsIGBcbiAgICAgICAgQ29udGVudCBvZiB0aGUgaWZyYW1lIGluIHdoaWNoIHRoZSB0ZXN0IGlzIGN1cnJlbnRseSBvcGVyYXRpbmcgZGlkIG5vdCBsb2FkLlxuICAgIGApLFxuXG4gICAgW1RFU1RfUlVOX0VSUk9SUy5jdXJyZW50SWZyYW1lTm90Rm91bmRFcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIFRoZSBpZnJhbWUgaW4gd2hpY2ggdGhlIHRlc3QgaXMgY3VycmVudGx5IG9wZXJhdGluZyBkb2VzIG5vdCBleGlzdCBhbnltb3JlLlxuICAgIGApLFxuXG4gICAgW1RFU1RfUlVOX0VSUk9SUy5jdXJyZW50SWZyYW1lSXNJbnZpc2libGVFcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIFRoZSBpZnJhbWUgaW4gd2hpY2ggdGhlIHRlc3QgaXMgY3VycmVudGx5IG9wZXJhdGluZyBpcyBub3QgdmlzaWJsZSBhbnltb3JlLlxuICAgIGApLFxuXG4gICAgW1RFU1RfUlVOX0VSUk9SUy5taXNzaW5nQXdhaXRFcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIEEgY2FsbCB0byBhbiBhc3luYyBmdW5jdGlvbiBpcyBub3QgYXdhaXRlZC4gVXNlIHRoZSBcImF3YWl0XCIga2V5d29yZCBiZWZvcmUgYWN0aW9ucywgYXNzZXJ0aW9ucyBvciBjaGFpbnMgb2YgdGhlbSB0byBlbnN1cmUgdGhhdCB0aGV5IHJ1biBpbiB0aGUgcmlnaHQgc2VxdWVuY2UuXG4gICAgYCksXG5cbiAgICBbVEVTVF9SVU5fRVJST1JTLmV4dGVybmFsQXNzZXJ0aW9uTGlicmFyeUVycm9yXTogZXJyID0+IG1hcmt1cChlcnIsIGBcbiAgICAgICAgJHtlc2NhcGVIdG1sKGVyci5lcnJNc2cpfVxuICAgIGApLFxuXG4gICAgW1RFU1RfUlVOX0VSUk9SUy5kb21Ob2RlQ2xpZW50RnVuY3Rpb25SZXN1bHRFcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgJHtlcnIuaW5zdGFudGlhdGlvbkNhbGxzaXRlTmFtZX0gY2Fubm90IHJldHVybiBET00gZWxlbWVudHMuIFVzZSBTZWxlY3RvciBmdW5jdGlvbnMgZm9yIHRoaXMgcHVycG9zZS5cbiAgICBgKSxcblxuICAgIFtURVNUX1JVTl9FUlJPUlMuaW52YWxpZFNlbGVjdG9yUmVzdWx0RXJyb3JdOiBlcnIgPT4gbWFya3VwKGVyciwgYFxuICAgICAgICBGdW5jdGlvbiB0aGF0IHNwZWNpZmllcyBhIHNlbGVjdG9yIGNhbiBvbmx5IHJldHVybiBhIERPTSBub2RlLCBhbiBhcnJheSBvZiBub2RlcywgTm9kZUxpc3QsIEhUTUxDb2xsZWN0aW9uLCBudWxsIG9yIHVuZGVmaW5lZC4gVXNlIENsaWVudEZ1bmN0aW9uIHRvIHJldHVybiBvdGhlciB2YWx1ZXMuXG4gICAgYCksXG5cbiAgICBbVEVTVF9SVU5fRVJST1JTLmFjdGlvblNlbGVjdG9yRXJyb3JdOiBlcnIgPT4gbWFya3VwKGVyciwgYFxuICAgICAgICBBY3Rpb24gXCIke2Vyci5zZWxlY3Rvck5hbWV9XCIgYXJndW1lbnQgZXJyb3I6XG5cbiAgICAgICAgJHtlc2NhcGVIdG1sKGVyci5lcnJNc2cpfVxuICAgIGApLFxuXG4gICAgW1RFU1RfUlVOX0VSUk9SUy5jYW5ub3RPYnRhaW5JbmZvRm9yRWxlbWVudFNwZWNpZmllZEJ5U2VsZWN0b3JFcnJvcl06IChlcnIsIHZpZXdwb3J0V2lkdGgpID0+IG1hcmt1cChlcnIsIGBcbiAgICAgICAgQ2Fubm90IG9idGFpbiBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbm9kZSBiZWNhdXNlIHRoZSBzcGVjaWZpZWQgc2VsZWN0b3IgZG9lcyBub3QgbWF0Y2ggYW55IG5vZGUgaW4gdGhlIERPTSB0cmVlLlxuXG4gICAgICAgICR7IGZvcm1hdFNlbGVjdG9yQ2FsbHN0YWNrKGVyci5hcGlGbkNoYWluLCBlcnIuYXBpRm5JbmRleCwgdmlld3BvcnRXaWR0aCkgfVxuICAgIGApLFxuXG4gICAgW1RFU1RfUlVOX0VSUk9SUy53aW5kb3dEaW1lbnNpb25zT3ZlcmZsb3dFcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIFVuYWJsZSB0byByZXNpemUgdGhlIHdpbmRvdyBiZWNhdXNlIHRoZSBzcGVjaWZpZWQgc2l6ZSBleGNlZWRzIHRoZSBzY3JlZW4gc2l6ZS4gT24gbWFjT1MsIGEgd2luZG93IGNhbm5vdCBiZSBsYXJnZXIgdGhhbiB0aGUgc2NyZWVuLlxuICAgIGApLFxuXG4gICAgW1RFU1RfUlVOX0VSUk9SUy5mb3JiaWRkZW5DaGFyYWN0ZXJzSW5TY3JlZW5zaG90UGF0aEVycm9yXTogZXJyID0+IG1hcmt1cChlcnIsIGBcbiAgICAgICAgVGhlcmUgYXJlIGZvcmJpZGRlbiBjaGFyYWN0ZXJzIGluIHRoZSBcIiR7ZXJyLnNjcmVlbnNob3RQYXRofVwiIHNjcmVlbnNob3QgcGF0aDpcbiAgICAgICAgJHtyZW5kZXJGb3JiaWRkZW5DaGFyc0xpc3QoZXJyLmZvcmJpZGRlbkNoYXJzTGlzdCl9XG4gICAgYCksXG5cbiAgICBbVEVTVF9SVU5fRVJST1JTLmludmFsaWRFbGVtZW50U2NyZWVuc2hvdERpbWVuc2lvbnNFcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgICBVbmFibGUgdG8gY2FwdHVyZSBhbiBlbGVtZW50IGltYWdlIGJlY2F1c2UgdGhlIHJlc3VsdGluZyBpbWFnZSAke2Vyci5kaW1lbnNpb25zfSAke2Vyci52ZXJifSB6ZXJvIG9yIG5lZ2F0aXZlLlxuICAgIGApLFxuXG4gICAgW1RFU1RfUlVOX0VSUk9SUy5yb2xlU3dpdGNoSW5Sb2xlSW5pdGlhbGl6ZXJFcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIFJvbGUgY2Fubm90IGJlIHN3aXRjaGVkIHdoaWxlIGFub3RoZXIgcm9sZSBpcyBiZWluZyBpbml0aWFsaXplZC5cbiAgICBgKSxcblxuICAgIFtURVNUX1JVTl9FUlJPUlMuYXNzZXJ0aW9uRXhlY3V0YWJsZUFyZ3VtZW50RXJyb3JdOiBlcnIgPT4gbWFya3VwKGVyciwgYFxuICAgICAgICBDYW5ub3QgZXZhbHVhdGUgdGhlIFwiJHtlcnIuYWN0dWFsVmFsdWV9XCIgZXhwcmVzc2lvbiBpbiB0aGUgXCIke2Vyci5hcmd1bWVudE5hbWV9XCIgcGFyYW1ldGVyIGJlY2F1c2Ugb2YgdGhlIGZvbGxvd2luZyBlcnJvcjpcblxuICAgICAgICAke2Vyci5lcnJNc2d9XG4gICAgYCksXG5cbiAgICBbVEVTVF9SVU5fRVJST1JTLmFzc2VydGlvbldpdGhvdXRNZXRob2RDYWxsRXJyb3JdOiBlcnIgPT4gbWFya3VwKGVyciwgYFxuICAgICAgICBBbiBhc3NlcnRpb24gbWV0aG9kIGlzIG5vdCBzcGVjaWZpZWQuXG4gICAgYCksXG5cbiAgICBbVEVTVF9SVU5fRVJST1JTLmFzc2VydGlvblVuYXdhaXRlZFByb21pc2VFcnJvcl06IGVyciA9PiBtYXJrdXAoZXJyLCBgXG4gICAgICAgIEF0dGVtcHRlZCB0byBydW4gYXNzZXJ0aW9ucyBvbiBhIFByb21pc2Ugb2JqZWN0LiBEaWQgeW91IGZvcmdldCB0byBhd2FpdCBpdD8gSWYgbm90LCBwYXNzIFwieyBhbGxvd1VuYXdhaXRlZFByb21pc2U6IHRydWUgfVwiIHRvIHRoZSBhc3NlcnRpb24gb3B0aW9ucy5cbiAgICBgKVxufTtcbiJdfQ==
